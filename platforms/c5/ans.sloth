REFILL For now, we can only use REFILL for comments.
DROP

CREATE (?DEFFOUND) 0 HERE ! 1 CELLS ALLOT

REFILL ?: is a simple implementation of conditional
REFILL compilation.
DROP DROP

: ?: 
	32 WORD FIND 
	SWAP DROP 
	0 = 
	0 PICK	
	1 +
	SOURCE SWAP DROP 
	OVER * SWAP 1 SWAP - + 
	>IN !
	(?DEFFOUND) !
;

REFILL ?\ allows multiline definitions with 
REFILL simple conditional compilation.
DROP DROP

: ?\ (?DEFFOUND) @ INVERT 2 + >IN ! ; IMMEDIATE

?: \ SOURCE >IN ! DROP ; IMMEDIATE

\ End of line comments can be used now.

\ SLOTH v1.0

\ TODO Explain why conditional compilation is so
\ important for SLOTH.

\ TODO Make next explanation more beautiful.

\ The first definition allows for conditional 
\ compilation on any ANS Forth.
\ Let's explain it:
\ 32 WORD FIND -- parse and find ( -- c-addr|xt 1|0|-1 )
\ SWAP DROP -- ( -- 1|0|-1)
\ 0 = 1 + -- ( -- 0|1 ) 0 if word exists, 1 if not
\ 0 PICK -- ( -- 0|1 0|1 )
\ SOURCE SWAP DROP -- ( -- 0|1 0|1 ILEN )
\ Now the formula f(x, y) = (x * y) + (1 - x) is applied,
\ where x is 0|1 (existence of a word) and y is the input
\ buffer length:
\ OVER * SWAP 1 SWAP - + -- ( -- 0|1 1|ILEN )
\ >IN ! -- ( -- 0|1 )
\ (?COMPILING) ! -- ( -- )

\ TODO Explain SLOTH

\ As per ANS Forth standard, all definitions names are
\ created and used in upper case (although I prefer the
\ upper case for definition/lower case for use, I think
\ its easier to read).

\ -- Stack comments ---------------------------------------

?: ( 41 WORD DROP ; IMMEDIATE

\ -- Compilation ------------------------------------------

?: , ( x -- ) HERE ! 1 CELLS ALLOT ;
?: C, ( char -- ) HERE C! 1 CHARS ALLOT ;

\ PLATFORM DEPENDENT
?: LITERAL ( C: x -- ) ( -- x ) 
?\		POSTPONE (LIT) , 
?\ ; IMMEDIATE

?: ' ( "<spaces>name" -- xt ) 32 WORD FIND DROP ; 

?: ['] ( "<spaces>name" -- ) ( R: -- xt ) 
?\		' POSTPONE LITERAL 
?\ ; IMMEDIATE

\ -- Variables and constants ------------------------------

?: VARIABLE ( "<spaces>name" -- ) CREATE 0 , ;
?: CONSTANT ( x "<spaces>name" -- ) CREATE , DOES> @ ;

?: BUFFER: ( u "<spaces>name" -- ; -- a-addr ) CREATE ALLOT ;

?: VALUE ( x "<spaces>name" -- ) CREATE , DOES> @ ;

\ -- Control structures -----------------------------------

\ This words have a good balance between simplicity and
\ usefulness. Some more complicated words (like DO/LOOP)
\ are not implemented now.

\ PLATFORM DEPENDENT (depends on implementation of BRANCH)
?: AHEAD ( C: -- orig ) ( -- ) 
?\		POSTPONE (BRANCH) HERE 0 , 
?\ ; IMMEDIATE

\ PLATFORM DEPENDENT (depends on implementation of ?BRANCH)
?: IF ( C: -- orig ) ( x -- ) 
?\		POSTPONE (?BRANCH) HERE 0 , 
?\ ; IMMEDIATE

?: THEN ( C: -- orig ) ( -- ) HERE OVER - SWAP ! ; IMMEDIATE

?: ELSE ( C: orig1 -- orig2 ) ( -- ) 
?\		POSTPONE AHEAD SWAP POSTPONE THEN 
?\ ; IMMEDIATE

?: BEGIN ( C: -- dest ) ( -- ) HERE ; IMMEDIATE

\ PLATFORM DEPENDENT (depends on implementation of ?BRANCH)
?: UNTIL ( C: dest -- ) ( x -- ) 
?\		POSTPONE (?BRANCH) HERE - , 
?\ ; IMMEDIATE

\ PLATFORM DEPENDENT (depends on implementation of BRANCH)
?: AGAIN ( C: dest -- ) ( -- ) 
?\		POSTPONE (BRANCH) HERE - , 
?\ ; IMMEDIATE

?: WHILE ( C: dest -- orig dest ) ( x -- ) 
?\		POSTPONE IF SWAP 
?\ ; IMMEDIATE

?: REPEAT	( C: orig dest -- ) ( -- ) 
?\		POSTPONE AGAIN POSTPONE THEN 
?\ ; IMMEDIATE

\ -- Conditional compilation of variables and constants ---

?: ?VARIABLE ( "<spaces>name" -- ) ?: ;

?: ?CONSTANT ( x "<spaces>name" -- ) 
?\		32 WORD FIND SWAP DROP
?\		IF DROP SOURCE >IN ! DROP
?\		ELSE 1 >IN !
?\		THEN
?\	;

\ ---------------------------------------------------------

\ Now that we have conditional compilation and basic 
\ control structures, we can implement a lot of fundamental 
\ words.

\ -- Stack shuffling --------------------------------------

?: DUP ( x -- x x ) 0 PICK ;
?: ?DUP	( x -- 0 | x x ) DUP IF DUP THEN ;

?: R@ ( -- x ) ( R: x -- x ) 
?\		POSTPONE R> POSTPONE DUP POSTPONE >R 
?\ ; IMMEDIATE

?: ROT ( x1 x2 x3 -- x2 x3 x1 ) >R SWAP R> SWAP ;	

\ Not ANS
?: -ROT ( x1 x2 x3 -- x3 x1 x2 ) ROT ROT ;

?: NIP ( x1 x2 -- x2 ) SWAP DROP ;

?: TUCK ( x1 x2 -- x2 x1 x2 ) >R R@ SWAP R> ;

?: ROLL ( xu xu-1 ... x0 u -- xu-1 ... x0 xu ) 
?\		DUP IF 
?\			SWAP >R 1 - RECURSE R> SWAP EXIT 
?\		THEN DROP 
?\ ;

?: 2DROP ( x1 x2 -- ) DROP DROP ;

?: 2DUP ( x1 x2 -- x1 x2 x1 x2 ) OVER OVER ;

?: 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 ) >R -ROT R> -ROT ;

?: 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 ) 3 PICK 3 PICK ;

?: 2>R ( x1 x2 -- ) ( R: -- x1 x2 ) 
?\		POSTPONE SWAP POSTPONE >R POSTPONE >R 
?\ ; IMMEDIATE

?: 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 ) 
?\		POSTPONE R> POSTPONE R> 
?\		POSTPONE SWAP POSTPONE 2DUP POSTPONE SWAP 
?\		POSTPONE >R POSTPONE >R 
?\ ; IMMEDIATE

?: 2R> ( -- x1 x2 ) ( R: x1 x2 -- ) 
?\		POSTPONE R> POSTPONE R> POSTPONE SWAP 
?\ ; IMMEDIATE

\ Not ANS
?: 2RDROP	( x1 x2 -- ) 
?\		POSTPONE R> POSTPONE R> 
?\		POSTPONE DROP POSTPONE DROP 
?\ ; IMMEDIATE

