# TODO
# I need to implement [ ]
# They must do two things, create a new lexical scope (that will be 
# destroyed after ] and enter compilation mode

import sys
from colorama import Fore, Back, Style

class Sloth:
    def __init__(self):
        # VM initialization
        self.init_stack()
        self.init_rstack()
        self.init_mem()
        self.init_inner()

        # Symbols
        self.init_symbols()

        # Outer interpreter
        self.init_outer()

        # Bootstrap
        self.bootstrap()

    # -------------------------------------------------------------------------
    # -- Virtual Machine ------------------------------------------------------
    # -------------------------------------------------------------------------

    # -- Parameter stack --

    def init_stack(self): self.s = [0]*256; self.sp = 0

    def push(self, v): self.s[self.sp] = v; self.sp = self.sp + 1
    def pop(self): v = self.s[self.sp - 1]; self.sp = self.sp - 1; return v

    def pick(self, a): return self.s[self.sp - a - 1]
    def place(self, a, v): self.s[self.sp - a - 1] = v

    # -- Return stack --

    def init_rstack(self): self.r = [0]*256; self.rp = 0

    def rpush(self, v): self.r[self.rp] = v; self.rp = self.rp + 1
    def rpop(self): v = self.r[self.rp - 1]; self.rp = self.rp - 1; return v

    # -- Memory --

    CELL = 1
    CHAR = 1

    def init_mem(self): 
        self.m = [0]*65536
        self.mp = 128 # input buffer

    def store(self, a, v): self.m[a] = v
    def fetch(self, a): return self.m[a]

    def cstore(self, a, v): self.m[a] = v
    def cfetch(self, a): return self.m[a]

    def comma(self, v): self.store(self.mp, v); self.mp = self.mp + Sloth.CELL
    def ccomma(self, v): self.cstore(self.mp, v); self.mp = self.mp + Sloth.CHAR

    def allot(self, v): t = self.mp; self.mp = self.mp + v; return t

    # -- Inner interpreter --

    def init_inner(self): 
        self.ip = -1
        self.primitives = []

    def do_prim(self, q): self.primitives[-1 - q](self)
    def call(self, q): self.rpush(self.ip); self.ip = q
    def execute(self, q): self.call(q) if q > 0 else self.do_prim(q)
    def exit(self): self.ip = -1 if self.rp == 0 else self.rpop()

    def opcode(self): o = self.m[self.ip]; self.ip = self.ip + 1; return o

    def inner(self): 
        t = self.rp
        while t <= self.rp and self.ip >= 0:
            self.trace()
            self.execute(self.opcode())

    def eval(self, q): self.execute(q); self.inner()

    def do(self, l): 
        for i in l:
            self.eval(i)

    def noname(self, l): self.primitives.append(l); return 0 - len(self.primitives)

    # -- Exceptions --

    # TODO It should be possible to use this exception system to get out of loops
    # but without losing what is present on the parameter stack. Maybe using one
    # exception value for that.

    def throw(self, v): 
        if not v == 0:
            raise RuntimeError('', v)

    def catch(self, q):
        tsp = self.sp
        trp = self.rp
        try:
            self.eval(q)
            self.push(0)
        except RuntimeError as e:
            self.sp = tsp
            self.rp = trp
            self.push(e.args[1])

    # -------------------------------------------------------------------------
    # -- Basic VM instructions ------------------------------------------------
    # -------------------------------------------------------------------------

    # -- Stack shufflers --

    def drop(self): self.pop()
    def dup(self): self.push(self.pick(0))
    def swap(self): a = self.pop(); b = self.pop(); self.push(a); self.push(b)
    def over(self): self.push(self.pick(1))

    # -- Arithmetic --

    def add(self): a = self.pop(); self.push(self.pop() + a)
    def sub(self): a = self.pop(); self.push(self.pop() - a)
    def mul(self): a = self.pop(); self.push(self.pop() * a)
    def div(self): a = self.pop(); self.push(self.pop() / a)
    def mod(self): a = self.pop(); self.push(self.pop() % a)

    # -- Bit --

    def _and(self): a = self.pop(); self.push(self.pop() & a)
    def _or(self): a = self.pop(); self.push(self.pop() | a)
    def _xor(self): a = self.pop(); self.push(self.pop() ^ a)
    def _invert(self): self.place(0, ~self.pick(0))

    def lshift(self): a = self.pop(); self.push(self.pop() << a)
    # def lrshift(self): python does not have logical right shift, do I need it?
    def rshift(self): a = self.pop(); self.push(self.pop() >> a)

    # -- Comparisons --

    def gt(self): a = self.pop(); b = self.pop(); self.push(-1 if b > a else 0)
    def eq(self): a = self.pop(); b = self.pop(); self.push(-1 if b == a else 0)
    def lt(self): a = self.pop(); b = self.pop(); self.push(-1 if b < a else 0)

    def zgt(self): self.push(-1 if self.pop() > 0 else 0)
    def zeq(self): self.push(-1 if self.pop() == 0 else 0)
    def zlt(self): self.push(-1 if self.pop() < 0 else 0)

    # -- Here starts the meaty part of Sloth !!! ------------------------------

    # -------------------------------------------------------------------------
    # -- Symbols --------------------------------------------------------------
    # -------------------------------------------------------------------------

    IMMEDIATE = 1

    def init_symbols(self):
        self.latest = 0

    def link(self, w): return w
    def binding(self, w): return w + Sloth.CELL
    def flags(self, w): return w + Sloth.CELL + Sloth.CELL
    def namelen(self, w): return w + Sloth.CELL + Sloth.CELL + Sloth.CHAR
    def name(self, w): return w + Sloth.CELL + Sloth.CELL + Sloth.CHAR + Sloth.CHAR

    def sym_size(self, u):
        return Sloth.CELL + Sloth.CELL + Sloth.CHAR + Sloth.CHAR + u*Sloth.CHAR

    def create_symbol(self, a, u):
        w = self.allot(self.sym_size(u))
        self.store(self.link(w), self.latest)
        self.latest = w
        self.store(self.binding(w), 0)
        self.cstore(self.flags(w), 0)
        self.cstore(self.namelen(w), u)
        for i in range(u):
            self.cstore(self.name(w) + i*Sloth.CHAR, self.cfetch(a + i*Sloth.CHAR))
        # alignment?
        return w

    def compare(self, a, u, w):
        if not u == self.cfetch(self.namelen(w)):
            return False
        for i in range(u):
            c1 = self.cfetch(a + i*Sloth.CHAR)
            c2 = self.cfetch(self.name(w) + i*Sloth.CHAR)
            c1 = (c1 - 32) if 97 <= c1 <= 122 else c1
            c2 = (c2 - 32) if 97 <= c2 <= 122 else c2
            if not c1 == c2:
                return False
        return True

    def find_symbol(self, a, u):
        w = self.latest
        while not w == 0:
            if self.compare(a, u, w):
                break
            w = self.fetch(self.link(w))
        return w

    def set(w, v): self.store(self.binding(w), v)
    def get(w): self.fetch(self.binding(w))

    # -------------------------------------------------------------------------
    # -- Outer interpreter (for bootstrapping) --------------------------------
    # -------------------------------------------------------------------------

    def init_outer(self):
        self.ibuf = 0
        self.ipos = 0
        self.ilen = 0

        self.tok = 0
        self.tlen = 0

        self.STATE = 0

    def token(self):
        while self.ipos < self.ilen and self.cfetch(self.ibuf + self.ipos*Sloth.CHAR) < 33:
            self.ipos = self.ipos + Sloth.CHAR 
        self.tok = self.ibuf + self.ipos*Sloth.CHAR
        self.tlen = 0
        while self.ipos < self.ilen and self.cfetch(self.ibuf + self.ipos*Sloth.CHAR) > 32:
            self.ipos = self.ipos + Sloth.CHAR 
            self.tlen = self.tlen + 1
        self.push(self.tok); self.push(self.tlen)

    def outer(self):
        while self.ipos < self.ilen:
            self.token()
            self.trace()
            u = self.pop(); a = self.pop()
            if u == 0:
                break
            w = self.find_symbol(a, u)
            if not w == 0:
                if self.STATE == 0 or self.cfetch(self.flags(w)) == Sloth.IMMEDIATE:
                    self.eval(self.fetch(self.binding(w)))
                else:
                    self.comma(self.fetch(self.binding(w)))
            else:
                self.throw(-13)
            self.trace()

    # -------------------------------------------------------------------------
    # -- Bootstrapping --------------------------------------------------------
    # -------------------------------------------------------------------------

    def str_to_data(self, s, a):
        for i in range(len(s)):
            self.m[a + i*Sloth.CHAR] = ord(s[i])
        self.ibuf = 0
        self.ipos = 0
        self.ilen = len(s)
        self.tok = 0
        self.tlen = 0

    def pad(self): return self.mp + 1024

    def colon(self, n, l):
        self.str_to_data(n, self.pad())
        w = self.create_symbol(self.pad(), len(n))
        xt = self.noname(l)
        self.store(self.binding(w), xt)
        return xt

    def immediate(self):
        self.cstore(self.flags(self.latest), Sloth.IMMEDIATE)

    def bootstrap(self):
        self.EXIT = self.colon('EXIT', lambda vm: vm.exit())
        self.doLIT = self.colon('doLIT', lambda vm: vm.do_lit())
        self.doFLIT = self.colon('doFLIT', lambda vm: vm.do_flit())
        self.doQUOTE = self.colon('doQUOTE', lambda vm: vm.do_quote())
        self.doSTRING = self.colon('doSTRING', lambda vm: vm.do_string())

        self.colon('EXECUTE', lambda vm: vm.execute(vm.pop()))
        self.colon('RECURSE', lambda vm: vm.recurse())
        self.colon('BYE', lambda vm: exit())

        self.OUTER = self.colon('OUTER', lambda vm: vm.outer())

        self.colon('#', lambda vm: vm.intnum()); self.immediate()
        self.colon('"', lambda vm: vm.strlit()); self.immediate()

        self.colon('\'', lambda vm: vm.quote())
        self.colon('!\'', lambda vm: vm.set_binding())
        self.colon('@\'', lambda vm: vm.get_binding())

        self.colon('DROP', lambda vm: vm.drop())
        self.colon('DUP', lambda vm: vm.dup())
        self.colon('SWAP', lambda vm: vm.swap())

        self.colon('@', lambda vm: vm.push(vm.fetch(vm.pop())))
        self.colon('!', lambda vm: vm.store(vm.pop(), vm.pop()))

        self.colon('+', lambda vm: vm.add())
        self.colon('-', lambda vm: vm.sub())
        self.colon('*', lambda vm: vm.mul())
        self.colon('/', lambda vm: vm.div())
        self.colon('MOD', lambda vm: vm.mod())

        self.colon('<', lambda vm: vm.lt())
        self.colon('=', lambda vm: vm.eq())
        self.colon('>', lambda vm: vm.gt())

        self.colon('0<', lambda vm: vm.zlt())
        self.colon('0=', lambda vm: vm.zeq())
        self.colon('0>', lambda vm: vm.zgt())

        self.colon('[', lambda vm: vm.start_quotation())
        self.colon(']', lambda vm: vm.end_quotation()); self.immediate()

        self.colon('CHOOSE', lambda vm: vm.choose())

        self.colon('TYPE', lambda vm: vm.type())

    def repl(self):
        while True:
            self.str_to_data(input('>>> '), 0)
            self.catch(self.OUTER)
            r = self.pop()
            if r == -13:
                self.push(self.tok); self.push(self.tlen); self.type(); print(' ?')

    # -------------------------------------------------------------------------
    # -- Words ----------------------------------------------------------------
    # -------------------------------------------------------------------------

    # -- Execution --

    def recurse(self): self.comma(self.latestxt)

    # -- Parsing numbers --

    def do_lit(self): self.push(self.opcode())
    def do_flit(self): self.push(self.opcode())

    def intnum(self):
        self.token()
        u = self.pop(); a = self.pop()
        s = self.data_to_str(a, u)
        try:
            n = int(s)
            if self.STATE == 0:
                self.push(n)
            else:
                self.comma(self.doLIT)
                self.comma(n)
        except ValueError as e:
            try:
                f = float(s)
                if self.STATE == 0:
                    self.push(f)
                else:
                    self.comma(doFLIT)
                    self.comma(f)
            except ValueError as e:
                print('Error converting number', e) 

    # -- Parsing strings --

    def do_string(self): 
        n = self.opcode()
        self.push(self.ip)
        self.push(n)
        self.ip = self.ip + n*Sloth.CHAR

    def strlit(self):
        self.ipos = self.ipos + 1
        a = self.ibuf + self.ipos*Sloth.CHAR
        u = 0
        while self.ipos < self.ilen and chr(self.cfetch(self.ibuf + self.ipos*Sloth.CHAR)) != '"':
            self.ipos = self.ipos + 1
            u = u + 1
        self.ipos = self.ipos + 1
        self.comma(self.doSTRING)
        self.comma(u)
        if self.STATE == 0:
            self.push(self.mp)
        for i in range(u):
            self.ccomma(self.cfetch(a + i*Sloth.CHAR))
        if self.STATE == 0:
            self.push(u)

    # -- Working with symbols --

    def find_or_create(self):
        self.token()
        u = self.pop(); a = self.pop()
        w = self.find_symbol(a, u)
        if w == 0:
            w = self.create_symbol(a, u)
        return w

    def quote(self): w = self.find_or_create(); self.push(w)
    def set_binding(self): w = self.find_or_create(); self.store(self.binding(w), self.pop())
    def get_binding(self): w = self.find_or_create(); self.push(self.fetch(self.binding(w)))

    # -- Quotations --

    def do_quote(self):
        self.push(self.ip + self.CELL)
        self.ip = self.ip + self.opcode()

    def start_quotation(self):
        self.comma(self.doQUOTE)
        self.push(self.mp)
        self.comma(0)
        self.latestxt = self.mp
        if self.STATE == 0:
            self.push(self.mp)
            self.swap()
        self.STATE = 1

    def end_quotation(self):
        self.comma(self.EXIT)
        self.STATE = 0
        a = self.pop()
        self.store(a, self.mp - a)

    # --

    def type(self):
        l = self.pop(); a = self.pop()
        for i in range(l):
            print(chr(self.fetch(a + i*Sloth.CHAR)), sep='', end='')

    def trace(self):
        print('[', self.STATE, ']', '', sep='', end='')
        print(self.mp, ' ', self.s[:self.sp], ' ', sep='', end='')
        print(': [', self.ip, '] ', sep = '', end = '')
        print(Fore.YELLOW, end='')
        if self.tlen > 0: self.push(self.tok); self.push(self.tlen); self.type()
        print(Style.RESET_ALL, end='')
        if self.ipos < self.ilen: self.push(self.ibuf + self.ipos); self.push(self.ilen); self.type()
        print()

    def data_to_str(self, a, u):
        s = ''
        for i in range(u):
            s = s + chr(self.cfetch(a + i*Sloth.CHAR))
        return s


def main():
    x = Sloth()

    x.repl()

if __name__ == '__main__':
    sys.exit(main())
