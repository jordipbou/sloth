
// SLOTH (SLOw forTH)

// Virtual Forth computer, API and Forth implementation on top of it
// jordipbou, 2024

// TODO Make here, align and allot work as there, talign and tallot when
// state < 0
// TODO Add cloning of an already bootstrapped VM (like forth in C)
// TODO Add floating point stack and instructions
// TODO Add object stack and memory and instructions

package io.github.jordipbou;

import java.net.URL;
import java.io.File;
import java.util.List;
import java.util.Scanner;
import java.util.ArrayList;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.util.function.Consumer;
import java.io.FileNotFoundException;
import java.nio.channels.FileChannel;

public class Sloth {

	// --------------------------------------------------------------------------
	// ** Virtual machine *******************************************************
	// --------------------------------------------------------------------------

	public static int CELL = 4;
	public static int CHAR = 2;	// Sloth uses 16 bit chars, as Java does

	// -- Parameter stack --

	int s[];					// Parameter stack
	int sp;						// Parameter stack pointer

	public void push(int v) { s[sp++] = v; }
	public int pop() { return s[--sp]; }

	// Helpers to get the most/least significant bits from a long integer, 
	// used for working with double cell numbers which are a requirement for
	// ANS Forth (even when not implementing the optional Double-Number word
	// set!).
	public long msp(long v) { return (v & 0xFFFFFFFF00000000L); }
	public long lsp(long v) { return (v & 0x00000000FFFFFFFFL); }

	public void push(long v) { push((int)lsp(v)); }

	// Push/pop variants (double and unsigned numbers)
	public void dpush(long v) { push(v); push(v >> 32); }
	public long dpop() { long b = lpop(); return msp(b << 32) + lsp(lpop()); }
	public long lpop() { return (long)s[--sp]; }
	public long upop() { return Integer.toUnsignedLong(s[--sp]); }
	public long udpop() { long b = upop(); return msp(b << 32) + lsp(upop()); }

	public int pick(int a) { return s[sp - a - 1]; }
	public void place(int a, int v) { s[sp - a - 1] = v; }

	// -- Return stack --

	int r[];					// Return stack
	int rp;						// Return stack pointer

	public void rpush(int v) { r[rp++] = v; }
	public int rpop() { return r[--rp]; }

	// -- Memory

	ByteBuffer mem;		// Dictionary memory

	public int dp;	// Dictionary pointer
	public int tp;	// Transient memory pointer

	public int MARGIN = 512;

	public int fetch(int a) { return mem.getInt(a); }
	public void store(int a, int v) { mem.putInt(a, v); }
	public char cfetch(int a) { return mem.getChar(a); }
	public void cstore(int a, char v) { mem.putChar(a, v); }

	public int aligned(int a) { return (a + (CELL - 1)) & ~(CELL - 1); }
	public int caligned(int a) { return (a + (CHAR - 1)) & ~(CHAR - 1); }

	public void cells() { place(0, pick(0) * CELL); }
	public void chars() { place(0, pick(0) * CHAR); }

	public void here(int v) { dp = v; }
	public void allot(int v) { 
		if (here() + v > mem.capacity()) _throw(-8);
		else here(here() + v);
	}

	public void there(int v) { tp = v; }
	public int tallot(int v) { 
		if (there() < (here() + MARGIN)) there(here() + MARGIN);
		if ((there() + v) > mem.capacity()) there(here() + MARGIN);
		// if ((there() + v) > mem.capacity()) throw exception ??!!
		int x = there();
		there(there() + v);
		return x;
	}

	// -- Inner interpreter

	public int ip;

	public List<Consumer<Sloth>> primitives;

	// NONAME adds an anonymous primitive that can be called by its xt
	public int noname(Consumer<Sloth> c) { primitives.add(c); return 0 - primitives.size(); }

	// TODO This should be defined in bootstrap_vm?
	public int token() { int v = fetch(ip); ip += CELL; return v; }

	public boolean valid_ip() { return ip >= 0 && ip < mem.capacity(); }
	public void do_prim(int p) { primitives.get(-1 - p).accept(this); }
	public void call(int q) { rpush(ip); ip = q; }
	public void execute(int q) { if (q < 0) do_prim(q); else call(q); }
	// Will execute until returning from current level, or an exception is thrown
	public void inner() {	int t = rp; while (t <= rp && valid_ip()) { execute(token()); } }

	public void trace(int q) {
		execute(q);
		int t = rp;
		while (t <= rp && valid_ip()) {
			System.out.printf("<%d> ", sp);
			for (int i = 0; i < sp; i++) System.out.printf("%d ", s[i]);
			System.out.printf(": [%d] %d ", ip, fetch(ip));
			for (int i = rp - 1; i >= t; i--) System.out.printf(": [%d] %d ", r[i], r[i] > 0 ? fetch(r[i]): r[i]);
			System.out.println();
			execute(token());
		}
	}
	// Eval is equivalent to execute but its meant to be called from Java, as
	// it starts a new inner interpreter
	public void eval(int q) { execute(q); inner(); }

	public void exit() { if (rp > 0) ip = rpop(); else ip = -1; }

	// -- Exceptions --

	public class SlothException extends RuntimeException {
		public int v;

		public SlothException(int v) { this.v = v; }
	}

	public void _throw(int v) { if (v != 0) { throw new SlothException(v); } }
	public void _catch(int q) {
		int tsp = sp;
		int trp = rp;
		try { 
			execute(q); 
			push(0);
		} catch(SlothException x) {
			sp = tsp;
			rp = trp;
			push(x.v);
		} catch(Exception e) {
			e.printStackTrace();
			sp = tsp;
			rp = trp;
			push(-1000);
		}
	}

	// ** Basic primitives *****************************************************

	// These functions are meant to be used as building blocks to construct
	// other words from Java.

	public int EXIT = -1;	// EXIT is the only required opcode value to be predefined

	public int NOOP;

	public int BRANCH, zBRANCH, LIT, BLOCK, STRING;

	public void branch() { ip += token(); }
	public void zbranch() { if(pop() == 0) ip += token(); else ip += CELL; }
	public void lit() { push(token()); }
	public void block() { push(ip + CELL); ip += token(); }
	public void string() { int l = token(); push(ip); push(l); ip = aligned(ip + (l * CHAR)); }

	public int EXECUTE;

	public void execute() { if (ip == -1) { execute(pop()); inner(); } else execute(pop()); }

	public int STORE, FETCH, CSTORE, CFETCH;

	public void fetch() { push(fetch(pop())); }
	public void store() { int a = pop(); store(a, pop()); }
	public void cfetch() { push(cfetch(pop())); }
	public void cstore() { int a = pop(); cstore(a, (char)pop()); }

	public int DROP, DUP, SWAP, OVER, ROT, PICK, DEPTH;

	public void drop() { pop(); }
	public void dup() { push(pick(0)); }
	public void swap() { int t = pick(0); place(0, pick(1)); place(1, t); }
	public void over() { push(pick(1)); }
	public void rot() { int t = pick(0); place(0, pick(2)); place(2, pick(1)); place(1, t); }
	public void pick() { push(pick(pop())); }
	public void depth() { push(sp); }

	public int TO_R, FETCH_R, FROM_R;

	public void to_r() { rpush(pop()); }
	public void fetch_r() { push(r[rp - 1]); }
	public void from_r() { push(rpop()); }

	public int ADD, SUB, MUL, DIV, MOD, TIMES_DIV_MOD, U_M_DIV_MOD, U_M_TIMES, LSHIFT, RSHIFT, TWO_DIV;

	public void add() { place(1, pick(1) + pick(0)); drop(); }
	public void sub() { place(1, pick(1) - pick(0)); drop(); }
	public void mul() { place(1, pick(1) * pick(0)); drop(); }
	public void div() { place(1, pick(1) / pick(0)); drop(); }
	public void mod() { place(1, pick(1) % pick(0)); drop(); }
	public void times_div_mod() { long n = lpop(); long d = lpop() * lpop(); push(d % n); push(d / n); };
	public void u_m_div_mod() { long u = upop(); long d = dpop(); push(Long.remainderUnsigned(d, u)); push(Long.divideUnsigned(d, u)); }
	public void u_m_times() { long r = upop() * upop(); dpush(r); }
	public void lshift() { place(1, pick(1) << pick(0)); drop(); }
	public void rshift() { place(1, pick(1) >>> pick(0)); drop(); }
	public void two_div() { place(0, pick(0) >> 1); }

	public int INVERT, AND, OR, XOR;

	public void invert() { place(0, ~pick(0)); }
	public void and() {  place(1, pick(1) & pick(0)); drop(); }
	public void or() { place(1, pick(1) | pick(0)); drop(); }
	public void xor() { place(1, pick(1) ^ pick(0)); drop(); }

	public int ULT, LT, EQ, GT, UGT;

	public void ult() { long v1 = upop(); push(Long.compareUnsigned(upop(), v1) < 0 ? -1 : 0); }
	public void lt() { place(1, pick(1) < pick(0) ? -1 : 0); drop(); }
	public void gt() { place(1, pick(1) > pick(0) ? -1 : 0); drop(); }
	public void eq() { place(1, pick(1) == pick(0) ? -1 : 0); drop(); }
	public void ugt() { long v1 = upop(); push(Long.compareUnsigned(upop(), v1) > 0 ? -1 : 0); }

	// -- Branching combinator --------------------------------------------------

	public int CHOOSE;

	public void choose() { int qf = pop(); int qt = pop(); if (pop() == 0) eval(qf); else eval(qt); }

	// -- Looping combinators ---------------------------------------------------

	public int DOLOOP, ILOOP, UNLOOP, LEAVE, I, J, K;

	int ix, jx, kx;	// Loop registers
	int lx; // Leave register

	public void ipush() { rpush(kx); kx = jx; jx = ix; lx = 0; }
	public void ipop() { lx = 0; ix = jx; jx = kx; kx = rpop(); }

	// Algorithm for doloop taken from pForth (pf_inner.c case ID_PLUS_LOOP)
	public void doloop() {
		ipush(); 
		int q = pop();
		ix = pop();
		int l = pop();
		if (ix != l) {
			for (int o = ix - l, d = 0;((o ^ (o + d)) & (o ^ d)) >= 0 && lx == 0;) {
				eval(q);
				if (lx == 0) { // Avoid pop if we're leaving
					d = pop();
					o = ix - l;
					ix += d;
				}
			}
		}
		ipop(); 
	}

	public void leave() { lx = -1; exit(); }

	public void i() { push(ix); }
	public void j() { push(jx); }
	public void k() { push(kx); }

	// TODO I'm not sure if I need iloop, I still have not used it
	public void iloop() {
		ipush();
		int q = pop();
		for (;lx == 0;) eval(q);
		ipop();
	}

	// -- Contiguous memory -----------------------------------------------------

	public int HERE, ALLOT, ALIGN, ALIGNED;

	public int here() { return dp; }
	public void allot() { allot(pop()); }
	public void align() { here((here() + (CELL - 1)) & ~(CELL - 1)); }
	public void aligned() { push(aligned(pop())); }

	// -- Transient memory ------------------------------------------------------

	public int THERE, TALLOT, TALIGN;

	public int there() { return tp; }
	public void tallot() { tallot(pop()); }
	public void talign() { there((there() + (CELL - 1)) & ~(CELL - 1)); }

	public int HOT;

	// Returns here or there depending on state
	public int hot() { if (fetch(STATE) >= 0) return here(); else return there(); }

	// -- Exceptions ------------------------------------------------------------

	public int THROW, CATCH;

	public void _throw() { _throw(pop()); }
	public void _catch() { _catch(pop()); }

	// -- Constructor

	public Sloth() { this(1024, 1024, 65536); }

	public Sloth(int ssize, int rsize, int memsize) {
		s = new int[ssize];
		r = new int[rsize];
		mem = ByteBuffer.allocateDirect(memsize);
		primitives = new ArrayList<Consumer<Sloth>>();
		sp = 0;
		rp = 0;
		ip = -1;

		// Functions are added to primitives list to be used from Forth code.
		// Their index is stored in variables to compile Forth code from Java.

		EXIT = noname((vm) -> exit());

		NOOP = noname((vm) -> { });

		BRANCH = noname((vm) -> branch());
		zBRANCH = noname((vm) -> zbranch());
		LIT = noname((vm) -> lit());
		BLOCK = noname((vm) -> block());
		STRING = noname((vm) -> string());

		EXECUTE = noname((vm) -> execute());

		STORE = noname((vm) -> store());
		FETCH = noname((vm) -> fetch());
		CSTORE = noname((vm) -> cstore());
		CFETCH = noname((vm) -> cfetch());

		DROP = noname((vm) -> drop());
		DUP = noname((vm) -> dup());
		SWAP = noname((vm) -> swap());
		OVER = noname((vm) -> over());
		ROT = noname((vm) -> rot());
		PICK = noname((vm) -> pick());
		DEPTH = noname((vm) -> depth());

		TO_R = noname((vm) -> to_r());
		FETCH_R = noname((vm) -> fetch_r());
		FROM_R = noname((vm) -> from_r());

		ADD = noname((vm) -> add());
		SUB = noname((vm) -> sub());
		MUL = noname((vm) -> mul());
		DIV = noname((vm) -> div());
		MOD = noname((vm) -> mod());
		TIMES_DIV_MOD = noname((vm) -> times_div_mod());
		U_M_DIV_MOD = noname((vm) -> u_m_div_mod());
		U_M_TIMES = noname((vm) -> u_m_times());
		LSHIFT = noname((vm) -> lshift());
		RSHIFT = noname((vm) -> rshift());
		TWO_DIV = noname((vm) -> two_div());

		INVERT = noname((vm) -> invert());
		AND = noname((vm) -> and());
		OR = noname((vm) -> or());
		XOR = noname((vm) -> xor());

		ULT = noname((vm) -> ult());
		LT = noname((vm) -> lt());
		EQ = noname((vm) -> eq());
		GT = noname((vm) -> gt());
		UGT = noname((vm) -> ugt());

		CHOOSE = noname((vm) -> choose());

		DOLOOP = noname((vm) -> doloop());
		ILOOP = noname((vm) -> iloop());
		UNLOOP = noname((vm) -> ipop());
		LEAVE = noname((vm) -> leave());
		I = noname((vm) -> i());
		J = noname((vm) -> j());
		K = noname((vm) -> k());

		HERE = noname((vm) -> push(here()));
		ALLOT = noname((vm) -> allot());
		ALIGN = noname((vm) -> align());
		ALIGNED = noname((vm) -> aligned());

		THERE = noname((vm) -> push(there()));
		TALLOT = noname((vm) -> tallot());
		TALIGN = noname((vm) -> talign());

		HOT = noname((vm) -> push(hot()));

		THROW = noname((vm) -> _throw());
		CATCH = noname((vm) -> _catch());
	}

	// --------------------------------------------------------------------------
	// ** ROM operations ********************************************************
	// --------------------------------------------------------------------------

	public void load_image(String s) throws FileNotFoundException, IOException {
		FileChannel channel = new FileInputStream(new File(s)).getChannel();
		mem.position(0);
		mem.limit(mem.capacity());
		channel.read(mem);
		channel.close();
	}

	public void save_image(String s) throws FileNotFoundException, IOException {
		FileChannel channel = new FileOutputStream(new File(s), false).getChannel();
		mem.position(here());
		mem.flip();
		channel.write(mem);
		channel.close();
		mem.limit(mem.capacity());
	}

	public void execute_image(String s) throws FileNotFoundException, IOException {
		load_image(s);
		eval(0);
	}

	// --------------------------------------------------------------------------
	// ** Bootstrapping from Java ***********************************************
	// --------------------------------------------------------------------------

	// This bootstrapping creates enough functions to have an outer interpreter
	// based on recognizers and wordlists.

	// -- Shared Java/Forth state -----------------------------------------------

	// First two cells of the dictionary are reserved to store a call to COLD
	// boot and an exit to not continue executing thru the rest of the image.

	public int BOOT = 0*CELL; // Two cells reserved for COLD BOOT (call + exit)

	// Variables

	public int STATE = 2*CELL;
	public int LEVEL = 3*CELL;
	public int LATEST = 4*CELL;
	public int LATESTXT = 5*CELL;
	public int CURRENT = 6*CELL;
	public int BASE = 7*CELL;
	public int SOURCE_ID = 8*CELL;
	public int IPOS = 9*CELL;
	public int FORTH_RECOGNIZER = 10*CELL;
	public int ORDER = 11*CELL;

	public int LAST_VAR = 12*CELL;

	// TODO This two should not be defined here

	public int LITERAL;
	public int COMPILE;
	public int DOES;

	// -- Outer interpreter -----------------------------------------------------

	public int INTERPRET;

	public void interpret() {
		do { 
			parse_name(); if (pick(0) == 0) break;	// Parse until no more input
			// System.out.printf("TOKEN: "); over(); over(); type(); System.out.println();
			push(FORTH_RECOGNIZER); recognize();		// Recognize the token
			// The absolute value of state is used to ensure the
			// correct recognizer is called even when state is negative.
			push((Math.abs(fetch(STATE)) * CELL) + pop()); at_execute();
			// dump_stack();
		} while (true);
		drop(); drop();
	}

	// -- Recognizers -----------------------------------------------------------

	public int RECTYPE_NULL;
	public int RECTYPE_NT;
	public int RECTYPE_NUM;

	public int RECTYPE;

	public int rectype(String s) {
		header(s);
		swap(); rot(); comma(); comma(); comma();
		return dt(latest());
	}

	public void rectype() { parse_name(); int u = pop(); rectype(data_to_str(pop(), u)); }

	public void recognize() {
		int r = fetch(pop()); // Recognizer stack identifier (address)
		int l = pop();
		int a = pop();
		int rl = fetch(r - CELL);	// Length of stack is at one cell before its adddress
		for (int i = r; i < r + (rl * CELL); i += CELL) {
			push(a);
			push(l);
			push(fetch(i));
			execute();
			if (pick(0) != RECTYPE_NULL) return;
			else drop();
		}
		push(a);
		push(l);
		push(RECTYPE_NULL);
	}

	public void rec_null() { type(); push(-13); _throw(); }

	// Recognizer for finding names --

	public void recint_nt() { 
		int w = pop();
		if (!has_flag(w, COLON)) { push(dt(w)); }
		if (xt(w) != 0) { push(xt(w)); execute(); }
	}
	public void reccomp_nt() {
		int w = pop();
		if (!has_flag(w, COLON)) { literal(dt(w)); }
		if (xt(w) != 0) {
			if (has_flag(w, IMMEDIATE)) { push(xt(w)); execute(); }
			else if (has_flag(w, INFINITE)) { push(xt(w)); execute(); }
			else { compile(xt(w)); }
		}
	}
	public void recpost_nt() {
		int w = pop();
		if (!has_flag(w, COLON)) { literal(dt(w)); compile(LITERAL); }
		if (xt(w) != 0) {
			if (has_flag(w, IMMEDIATE)) { compile(xt(w)); }
			else if (has_flag(w, INFINITE)) { push(xt(w)); execute(); }
			else { literal(xt(w)); compile(COMPILE); }
		}
	}

	public void rec_find() { 
		find_name();
		if (pick(0) != 0) push(RECTYPE_NT);
		else { drop(); push(RECTYPE_NULL); }
	}

	// Recognizer for single cell numbers --

	public void recint_num() { /* NOOP */ }
	public void reccomp_num() { literal(); }
	// TODO This is not correct, it should compile code to compile a literal
	public void recpost_num() { literal(); }

	public void rec_num() {
		int l = pop();
		int a = pop();
		if (cfetch(a) == '\'' && cfetch(a + CHAR + CHAR) == '\'') {
			push(cfetch(a + CHAR));	
			push(RECTYPE_NUM);
		} else {
			int n;
			StringBuilder sb = new StringBuilder();
			int r = fetch(BASE);
			int start = 0;
			if (cfetch(a) == '#') { r = 10; start = 1; }
			else if (cfetch(a) == '$') { r = 16; start = 1; }
			else if (cfetch(a) == '%') { r = 2; start = 1; }
			for (int i = start; i < l; i++) sb.append(cfetch(a + (i * CHAR)));
			try {
				n = Integer.parseInt(sb.toString(), r);
				push(n);
				push(RECTYPE_NUM);
			} catch (NumberFormatException e) {
				push(RECTYPE_NULL);
			}
		}
	}

	// -- Evaluation ------------------------------------------------------------

	public void evaluate(String str) { str_to_transient(str); evaluate(); }
	public void evaluate() {
		// Save input source
		int l = ilen;
		int b = ibuf;
		int p = fetch(IPOS);
		int source_id = fetch(SOURCE_ID);
		// Get string from parameter stack
		ilen = pop();
		ibuf = pop();
		store(IPOS, 0);
		store(SOURCE_ID, -1); // Set source id to string
		interpret();
		// Restore input source
		store(SOURCE_ID, source_id);
		store(IPOS, p);
		ibuf = b;
		ilen = l;
	}

	// -- Parsing ---------------------------------------------------------------

	public void parse_name() {
		int ipos = fetch(IPOS);
		while (ipos < ilen && cfetch(ibuf + (ipos * CHAR)) < 33) ipos++;
		push(ibuf + (ipos * CHAR));
		while (ipos < ilen && cfetch(ibuf + (ipos * CHAR)) > 32) ipos++;
		push((ibuf + (ipos * CHAR) - pick(0)) / CHAR);
		store(IPOS, ipos + (ipos < ilen ? 1 : 0));
	}

	// -- Input buffer ----------------------------------------------------------

	public int ibuf;
	public int ilen;

	public String last_dir = "";
	public BufferedReader last_buffered_reader;

	public void refill() {
	switch (fetch(SOURCE_ID)) {
		case -1: push(-1); break;
		case 0: 
			ibuf = tallot(80);
			push(ibuf); 
			push(80); 
			accept();
			ilen = pop();
			store(IPOS, 0);
			push(-1); 
			break;
		default: 
			try {
				str_to_transient(last_buffered_reader.readLine());
				ilen = pop();
				ibuf = pop();
				store(IPOS, 0);
				push(-1);
			} catch (Exception e) {
				push(0);
			}
		}
	}

	public void include(String filename) {
	 	File file = new File(filename);
		if (!file.exists()) {
			file = new File(last_dir + filename);
			if (!file.exists()) {
				_throw(-38);
			}
		}

		try {
			String prevDir = last_dir;
			last_dir = file.getAbsolutePath().replace(file.getName(), "");

			BufferedReader prevReader = last_buffered_reader;
	 		last_buffered_reader = 
				new BufferedReader(
					new InputStreamReader(
						new FileInputStream(file)));

			int last_source_id = fetch(SOURCE_ID);
			store(SOURCE_ID, 1);

	 		while (true) {
				// // TODO Check sp 
				// int tsp = sp;

	 			String line = last_buffered_reader.readLine();
	 			if (line == null) break;
				// System.out.println(line);
				str_to_transient(line);
				ilen = pop();
				ibuf = pop();
				store(IPOS, 0);
				try {
					interpret();
				} catch(Exception e) {
					System.out.printf("ERROR: %s\n", line);
					throw(e);
				}

				// if (tsp != sp) {
				// 	System.out.printf("STACK NOT BALANCED ON: %s\n", line);
				// 	dump_stack();
				// }
	 		}

			store(SOURCE_ID, last_source_id);
			last_buffered_reader.close();
			last_buffered_reader = prevReader;
			last_dir = prevDir;
		} catch(FileNotFoundException e) {
			_throw(-38);
		} catch(IOException e) {
			_throw(-37);
		}
	}

	// -- Finding words ---------------------------------------------------------

	// Case insensitive comparison of a string and a word name 
	public boolean compare(int n, int l, int w) {
		if (l != namelen(w)) return false;
		for (int i = 0; i < l; i++) {
			char a = cfetch(n + (i * CHAR));
			char b = cfetch(name(w) + (i * CHAR));
			if (a >= 97 && a <= 122) a -= 32;
			if (b >= 97 && b <= 122) b-= 32;
			if (a != b) return false;
		}
		return true;
	}

	public boolean in_order(int w) {
		int order_len = fetch(fetch(ORDER) - CELL);
		for (int i = 0; i < (order_len * CELL); i += CELL) {
			if (wordlist(w) == fetch(fetch(ORDER) + i)) return true;
		}
		return false;
	}

	public int find_name(String s) { str_to_transient(s); find_name(); return pop(); }
	public void find_name() {
		int l = pop(); 
		int n = pop();
		int w = latest();
		while (w != 0) {
			if (compare(n, l, w) && !has_flag(w, HIDDEN) && in_order(w)) break;
			w = link(w);
		}
		push(w);
	}

	public void tick() {
		parse_name();
		int l = pick(0);
		int a = pick(1);
		find_name();
		if (pick(0) != 0) {
			push(xt(pop()));
		} else {
			push(a);
			push(l);
			_throw(-13);
		}
	}

	// Helpers for working with string objects

	public void str_to_transient(String str) {
		int t = tallot(str.length() * CHAR);
		push(t);
		for (int i = 0; i < str.length(); i++) cstore(t + (i * CHAR), str.charAt(i));
		push(str.length());
	}

	public String data_to_str(int a, int u) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < u; i++) sb.append(cfetch(a + (i * CHAR)));
		return sb.toString();
	}

	// -- Compilation -----------------------------------------------------------

	// If state is negative, everything is compiled to transient memory.
	// This will allow using immediate words like IF or [: in interpret
	// mode.

	public void comma(int v) { 
		if (fetch(STATE) >= 0) {
			store(here(), v); allot(CELL); 
		} else {
			store(there(), v); tallot(CELL);
		}
	}
	public void ccomma(char v) { 
		if (fetch(STATE) >= 0) {
			cstore(here(), v); allot(CHAR);
		} else {
			cstore(there(), v); tallot(CHAR);
		}
	}

	public void compile(int v) { comma(v); }
	public void literal(int v) { compile(LIT); compile(v); }

	public void postpone() {
		parse_name();
		find_name();
		int w = pop();
		if (has_flag(w, IMMEDIATE)) {	compile(xt(w));	} 
		else { literal(xt(w)); compile(COMPILE);	}
	}

	// -- Defining words --------------------------------------------------------

	public static char HIDDEN = 1;
	public static char COLON = 2;
	public static char IMMEDIATE = 4;
	public static char INFINITE = 8;

	public int latest() { return fetch(LATEST); }
	public void latest(int v) { store(LATEST, v); }

	public int latestxt() { return fetch(LATESTXT); }
	public void latestxt(int v) { store(LATESTXT, v); }

	public int link(int w) { return fetch(w); }

	public int xt(int w) { return fetch(w + CELL); }
	public void xt(int w, int v) { store(w + CELL, v); }

	public int dt(int w) { return fetch(w + CELL + CELL); }
	public void dt(int w, int v) { store(w + CELL + CELL, v); }

	public int wordlist(int w) { return fetch(w + CELL + CELL + CELL); }
	public void wordlist(int w, int v) { store(w + CELL + CELL + CELL, v); }

	public char flags(int w) { return cfetch(w + CELL + CELL + CELL + CELL); }
	public void flags(int w, char v) { cstore(w + CELL + CELL + CELL + CELL, v); }
	public void set_flag(int w, char v) { flags(w, (char)(flags(w) | v)); }
	public void unset_flag(int w, char v) { flags(w, (char)(flags(w) & ~v)); }
	public boolean has_flag(int w, char v) { return (flags(w) & v) == v; }

	public char namelen(int w) { return cfetch(w + CELL + CELL + CELL + CELL + CHAR); }
	public int name(int w) { return w + CELL + CELL + CELL + CELL + CHAR + CHAR; }

	public void set_hidden() { set_flag(latest(), (char)(flags(latest()) | HIDDEN)); }
	public void set_colon() { set_flag(latest(), (char)(flags(latest()) | COLON)); }
	public void set_immediate() { set_flag(latest(), (char)(flags(latest()) | IMMEDIATE)); }
	public void set_infinite() { set_flag(latest(), (char)(flags(latest()) | INFINITE)); }

	public void header(String s) { str_to_transient(s); header(); }
	public void header() {
		int l = pop();
		int a = pop();
		align();
		int w = here();																				// Address of NT/XT
		comma(latest()); latest(w);														// LINK
		comma(0);																							// XT
		comma(0);																							// DT
		comma(fetch(CURRENT));																// WORDLIST
		ccomma((char)0);																			// FLAGS
		ccomma((char)l);																			// NAME LENGTH
		for (int i = 0; i < l; i++) ccomma(cfetch(a + (i * CHAR)));	// Name
		align();
		dt(latest(), here());
	}

	public void create() { parse_name(); if (pick(0) == 0) { drop(); drop(); _throw(-16); } header(); }

	// Creates a word only if it does not exist in the dictionary
	// Useful for bootstrapping
	public void maybe_colon() { 
		parse_name();
		find_name(); 
		store(IPOS, pop() == 0 ? 1 : ilen); 
	}

	// COLON is used to create a named primitive 
	public int colon(String s, Consumer<Sloth> c) { return colon(s, noname(c)); }
	public int colon(String s, int xt) { header(s);	xt(latest(), xt);	set_colon(); return xt;	}
	public void colon() {
		parse_name();
		header();
		xt(latest(), dt(latest()));
		latestxt(xt(latest()));
		set_flag(latest(), COLON);
		set_flag(latest(), HIDDEN);
		store(STATE, 1);
		push(sp);
	}

	public void semicolon() { 
		compile(EXIT); 
		store(STATE, 0); 
		// Don't do this for nonames
		if (xt(latest()) == latestxt()) {
			if (pop() != sp) _throw(-22); // Control structure mismatch
			unset_flag(latest(), HIDDEN); 
		}
	};

	// CREATE DOES> from Java becomes:
	// colon("CONSTANT", (vm) -> { create(); comma(); does((vm) -> fetch()); });
	public void does(Consumer<Sloth> c) { xt(latest(), noname(c)); }
	public void does() { literal(here() + 16); compile(DOES); compile(EXIT); }

	// -- Control structures ----------------------------------------------------

	// TODO Make them state aware, as quotations

	public void ahead() { compile(BRANCH); push(hot()); comma(0); }
	public void _if() { compile(zBRANCH); push(hot()); comma(0); }
	public void then() { int a = pop(); store(a, hot() - a); }

	public void begin() { push(hot()); }
	public void until() { compile(zBRANCH); comma(pop() - hot()); }
	public void again() { compile(BRANCH); comma(pop() - hot()); }

	public void _else() { ahead(); swap(); then(); }

	public void _while() { _if(); swap(); }
	public void repeat() { again(); then(); }

	// -- Quotations ------------------------------------------------------------

	public void start_quotation() {
		push(latestxt());	// Push latestxt to allow nested recurses
		store(LEVEL, fetch(LEVEL) + 1);
		if (fetch(STATE) == 0) {
			// Quotation in interpretation mode
			tallot(1024); // To not eat the input buffer
			store(STATE, -1);
			push(there());
			swap();
		} else {
			// Nested quotation (inside a colon or another quotation)
			compile(BLOCK);
			push(hot());
			comma(0);
		}
		latestxt(hot());
	}

	public void end_quotation() {
		compile(EXIT);
		store(LEVEL, fetch(LEVEL) - 1);
		if (fetch(LEVEL) == 0 && fetch(STATE) == -1) store(STATE, 0);
		else { int a = pop(); store(a, hot() - a); }
		latestxt(pop());
	}

	// TODO When bootstrapping, words are created here that will need to be 
	// defined as a primitive if loading an image. Differentiate what words
	// can be recreated and what words can't.

	// In theory, control structures must be defined in Java because are
	// platform dependent, but they must be bootstrapped even when loading
	// an image...

	public void bootstrap() {
		allot(LAST_VAR);

		store(BOOT, EXIT);

		store(STATE, 0);
		store(LEVEL, 0);
		store(LATEST, 0);
		store(LATESTXT, 0);
		store(CURRENT, 1);
		store(BASE, 10);
		store(SOURCE_ID, 0);
		store(IPOS, 0);

		// Define basic search order
		comma(8); // Max number of items on the search order stack
		comma(1); // Current number of items on the search order stack
		store(ORDER, here());
		comma(1);	// ROOT wordlist to be searched
		allot(7 * CELL); // Leave space for the rest of the possible wordlists

		colon("ORDER", (vm) -> push(ORDER));

		// Define basic recognizer types

		push(noname((vm) -> rec_null()));
		dup();
		dup();
		RECTYPE_NULL = rectype("RECTYPE-NULL");

		push(noname((vm) -> recint_nt()));
		push(noname((vm) -> reccomp_nt()));
		push(noname((vm) -> recpost_nt()));
		RECTYPE_NT = rectype("RECTYPE-NT");

		push(noname((vm) -> recint_num()));
		push(noname((vm) -> reccomp_num()));
		push(noname((vm) -> recpost_num()));
		RECTYPE_NUM = rectype("RECTYPE-NUM");

		colon("RECTYPE:", (vm) -> rectype());

		// push(noname((vm) -> recint_dnum()));
		// push(noname((vm) -> reccomp_dnum()));
		// push(noname((vm) -> recpost_dnum()));
		// RECTYPE_DNUM = rectype("RECTYPE-DNUM");

		// push(noname((vm) -> recint_string()));
		// push(noname((vm) -> reccomp_string()));
		// push(noname((vm) -> recpost_string()));
		// RECTYPE_STRING = rectype("RECTYPE-STRING");

		// Define default recognizer
		comma(8);
		comma(2);
		store(FORTH_RECOGNIZER, here());
		comma(noname((vm) -> rec_find()));
		//comma(noname((vm) -> rec_string()));
		comma(noname((vm) -> rec_num()));
		//comma(noname((vm) -> rec_dnum()));
		allot(6 * CELL);

		colon("FORTH-RECOGNIZER", (vm) -> push(FORTH_RECOGNIZER));

		// Create headers for the basic primitives

		colon("EXIT", EXIT);

		colon("NOOP", NOOP);

		colon("BRANCH", BRANCH);
		colon("?BRANCH", zBRANCH);
		colon("LIT", LIT);
		colon("BLOCK", BLOCK);
		colon("STRING", STRING);

		colon("EXECUTE", EXECUTE);

		colon("!", STORE);
		colon("@", FETCH);
		colon("C!", CSTORE);
		colon("C@", CFETCH);

		colon("DROP", DROP);
		colon("DUP", DUP);
		colon("SWAP", SWAP);
		colon("OVER", OVER);
		colon("ROT", ROT);
		colon("PICK", PICK);
		colon("DEPTH", DEPTH);

		colon(">R", TO_R);
		colon("R@", FETCH_R);
		colon("R>", FROM_R);

		colon("+", ADD);
		colon("-", SUB);
		colon("*", MUL);
		colon("/", DIV);
		colon("MOD", MOD);
		colon("*/MOD", TIMES_DIV_MOD);
		colon("UM/MOD", U_M_DIV_MOD);
		colon("UM*", U_M_TIMES);
		colon("LSHIFT", LSHIFT);
		colon("RSHIFT", RSHIFT);
		colon("2/", TWO_DIV);

		colon("INVERT", INVERT);
		colon("AND", AND);
		colon("OR", OR);
		colon("XOR", XOR);

		colon("U<", ULT);
		colon("<", LT);
		colon("=", EQ);
		colon(">", GT);
		colon("U>", UGT);
		
		colon("CHOOSE", CHOOSE);

		colon("DOLOOP", DOLOOP);
		colon("ILOOP", ILOOP);
		colon("I", I);
		colon("J", J);
		colon("K", K);
		colon("UNLOOP", UNLOOP);
		colon("LEAVE", LEAVE); 

		colon("HERE", HERE);
		colon("ALLOT", ALLOT);
		colon("ALIGN", ALIGN);
		colon("ALIGNED", ALIGNED);

		colon("THERE", THERE);
		colon("TALLOT", TALLOT);
		colon("TALIGN", TALIGN);

		colon("HOT", HOT);

		colon("THROW", THROW);
		colon("CATCH", CATCH);

		// Input/output

		// These words are vectored, if KEY/EMIT/ACCEPT variables have a 
		// value different than 0, the primitive indicated by that variable
		// will be called from this functions.

		colon("EMIT", (vm) -> emit());
		colon("KEY", (vm) -> key());
		colon("TYPE", (vm) -> type());	// TODO Remove this one
		colon("ACCEPT", (vm) -> accept());	// TODO Remove this one

		// Outer interpreter

		INTERPRET = colon("INTERPRET", (vm) -> interpret());
		COMPILE = colon("COMPILE,", (vm) -> compile());

		// Compiler words

		colon("STATE", (vm) -> push(STATE));
		colon("BASE", (vm) -> push(BASE));
		colon("LATEST", (vm) -> push(LATEST));
		colon("CURRENT", (vm) -> push(CURRENT));

		colon("CELLS", (vm) -> push(pop() * CELL));
		colon("CHARS", (vm) -> push(pop() * CHAR));

		colon(",", (vm) -> comma());
		colon("C,", (vm) -> ccomma());

		colon(":", (vm) -> colon());
		colon(";", (vm) -> semicolon()); set_immediate();
		colon("IMMEDIATE", (vm) -> set_immediate());
		colon("POSTPONE", (vm) -> postpone()); set_immediate();
		colon("RECURSE", (vm) -> compile(latestxt())); set_immediate();

		colon("CREATE", (vm) -> create());
		DOES = noname((vm) -> xt(latest(), pop()));
		colon("DOES>", (vm) -> does()); set_immediate(); 

	 	colon(":NONAME", (vm) -> { push(here()); latestxt(here()); store(STATE, 1); });
		colon("[:", (vm) -> start_quotation()); set_immediate();
		colon(";]", (vm) -> end_quotation()); set_immediate();

		colon("PARSE/TOKEN", (vm) -> parse_name());
		colon("FIND-NAME", (vm) -> find_name());
		colon("'", (vm) -> tick());

		colon("]", (vm) -> store(STATE, fetch(STATE) + 1)); set_infinite();
		colon("]]", (vm) -> store(STATE, 2)); set_infinite();
		colon("[[", (vm) -> store(STATE, 0)); set_infinite();
		colon("[", (vm) -> store(STATE, fetch(STATE) - 1)); set_infinite();

		colon("SOURCE", (vm) -> { push(ibuf); push(ilen); });
		colon(">IN", (vm) -> push(IPOS));
		colon("REFILL", (vm) -> refill());

		colon("EVALUATE", (vm) -> evaluate());
    colon("INCLUDED", (vm) -> { int u = pop(); include(data_to_str(pop(), u)); });

		// Tools 

		colon("TRACE", (vm) -> { parse_name(); find_name(); trace(xt(pop())); });
		colon("DUMP", (vm) -> { int l = pop(); dump_memory(pop(), l); });
		colon("BYE", (vm) -> System.exit(0));


		//    // Control structures --

		//    colon("AHEAD", (vm) -> ahead()); set_immediate();
		//    colon("IF", (vm) -> _if()); set_immediate();
		//    colon("THEN", (vm) -> then()); set_immediate();

		//    colon("BEGIN", (vm) -> begin()); set_immediate();
		//    colon("UNTIL", (vm) -> until()); set_immediate();
		//    colon("AGAIN", (vm) -> again()); set_immediate();

		//    colon("ELSE", (vm) -> _else()); set_immediate();

		//    colon("WHILE", (vm) -> _while()); set_immediate();
		//    colon("REPEAT", (vm) -> repeat()); set_immediate();

		//    // Quotations (for interpretation and compilation states)

		//    colon("INCLUDE", (vm) -> { int u = pop(); include(data_to_str(pop(), u)); });

		//    COMPILE = colon("COMPILE", (vm) -> comma(pop()));
		//    LITERAL = colon("LITERAL", (vm) -> literal(pop())); set_immediate();

		//    colon("CREATE", (vm) -> create());
		//    DOES = noname((vm) -> xt(latest(), pop()));
		//    colon("DOES>", (vm) -> does()); set_immediate(); 

		//    colon("STATE", (vm) -> push(STATE));

		//    colon("CELLS", (vm) -> push(pop() * CELL));
		//    colon("CHARS", (vm) -> push(pop() * CHAR));

		//    colon("HERE", (vm) -> push(here()));
		//    colon("ALLOT", (vm) -> allot());

		//    // ------------------------------------------------------------------------

		//    // Check if next instructions are so basic that should be added to VM

		//    colon("*/MOD", (vm) -> { long n = lpop(); long d = lpop() * lpop(); push(d % n); push(d / n); });

		//    // Tools, useful for debugging but needed for bootstrapping?

		// colon("[:", (vm) -> {
		// 	rpush(latestxt());
		// 	store(LEVEL, fetch(LEVEL) + 1);
		// 	if (fetch(STATE) == 0) {
		// 		// Quotation in interpretation mode
		// 		store(STATE, -1);
		// 		push(there());
		// 		latestxt(there());
		// 	} else {
		// 		// Nested quotation (inside a colon or another quotation)
		// 		compile(BLOCK);
		// 		push(hot());
		// 		comma(0);
		// 		latestxt(hot());
		// 	}
		// }); set_immediate();

		// colon(";]", (vm) -> { 
		// 	compile(EXIT);
		// 	store(LEVEL, fetch(LEVEL) - 1);
		// 	if (fetch(LEVEL) == 0 && fetch(STATE) == -1) store(STATE, 0);
		// 	else { int a = pop(); store(a, hot() - a); }
		// 	latestxt(rpop());
		// }); set_immediate();

	// -- Primitives ----------------------------------------------------------


		// colon("2>R", (vm) -> two_to_r());
		// colon("2R>", (vm) -> two_from_r());

		// colon("2@", (vm) -> two_fetch());

		// colon("ALIGN", (vm) -> align());

		// colon("'", (vm) -> tick());
		// colon("EXECUTE", (vm) -> execute());

		// colon("PARSE-NAME", (vm) -> parse_name());
		// colon("FIND-NAME", (vm) -> find_name());

		// colon(":", (vm) -> { create(); set_colon(); set_hidden(); xt(latest(), dt(latest())); latestxt(xt(latest())); store(STATE, 1); });
		// colon(";", (vm) -> { compile(EXIT); store(STATE, 0); if (latestxt() == xt(latest())) unset_flag(latest(), HIDDEN); }); set_immediate();
		// colon("RECURSE", (vm) -> comma(latestxt())); set_immediate();

		// colon("TRACE", (vm) -> { tick(); trace(pop()); });
		// colon("DUMP", (vm) -> { int l = pop(); dump_memory(pop(), l); });

		// colon("BYE", (vm) -> System.exit(0));

		// // 

		// colon("HERE", (vm) -> push(here()));
		// colon("THERE", (vm) -> push(there()));

		// // Loops

		// colon("TIMES", (vm) -> { ipush(); int q = pop(); int n = pop(); for (ix = 0; ix < n; ix++) eval(q); ipop(); });
		// colon("DO/LOOP", (vm) -> { ipush(); int q = pop(); int i = pop(); int l = pop(); for (ix = i; ix < l; ix++) eval(q); ipop(); });
		// // TODO DO/+LOOP does not work for -10 0 with -1 step
		// colon("DO/+LOOP", (vm) -> { ipush(); int q = pop(); int i = pop(); int l = pop(); for (ix = i; ix < l;) { eval(q); ix += pop(); } ipop(); });

		// colon("I", (vm) -> push(ix));
		// colon("J", (vm) -> push(jx));
		// colon("K", (vm) -> push(kx));

		// // Input/output

		// colon("EMIT", (vm) -> emit());
		// colon("KEY", (vm) -> key());

		// // --

		// colon("LOAD-IMAGE", (vm) -> { try { load_image("sloth.rom"); } catch(FileNotFoundException e) { _throw(-38); } catch (IOException e) { _throw(-37); } });
		// colon("SAVE-IMAGE", (vm) -> { try { save_image("sloth.rom"); } catch(FileNotFoundException e) { _throw(-38); } catch (IOException e) { _throw(-37); } });
	}





	// **************************************************************************
	// Temporal rearrangement of some functions
	// **************************************************************************

	public void at_execute() { execute(fetch(pop())); }

	public void two_to_r() { swap(); to_r(); to_r(); }
	public void two_from_r() { from_r(); from_r(); swap(); }

	public void two_fetch() { int a = pop(); push(fetch(a)); push(fetch(a + CELL)); }

	// TODO How to store strings to use type instead of printf?

	public void quit() {
		rp = 0;							// Empty the return stack
		store(STATE, 0);		// Set outer interpreter to interpretation state
		do {
			refill();					// Refill the input buffer from file or input device
			if (pick(0) == 0) break; else drop();
			_catch(INTERPRET);
			switch (pick(0)) {
				case 0: drop(); System.out.printf(" OK "); dump_stack(); break;
				case -1: store(STATE, 0); /* Aborted */ sp = 0; break;
				case -2: store(STATE, 0); /* Display message from abort" */ sp = 0; break;
				case -13: store(STATE, 0); drop(); push('?'); emit(); cr(); sp = 0; break;
				default: store(STATE, 0); System.out.printf(" #%d\n", pop()); sp = 0; break;
			}
		} while(true);
	}

	// !!! These recognizers are not needed for bootstrapping,
	// and they can be added later !!!

	// // Recognizer for double cell numbers --

	// public void recint_dnum() { /* NOOP */ }
	// public void reccomp_dnum() { two_literal(); }
	// public void recpost_dnum() { two_literal(); }

	// public void rec_dnum() {
	// 	int l = pop();
	// 	int a = pop();
	// 	if (cfetch(a + ((l-1)*CHAR)) == '.') {
	// 		StringBuilder sb = new StringBuilder();
	// 		for (int i = 0; i < (l - 1); i++) sb.append(cfetch(a + (i * CHAR)));
	// 		long n;
	// 		try {
	// 			n = Long.parseLong(sb.toString(), fetch(BASE));
	// 			dpush(n);
	// 			push(RECTYPE_DNUM);
	// 		} catch (NumberFormatException e) {
	// 			push(RECTYPE_NULL);
	// 		}
	// 	} else {
	// 		push(RECTYPE_NULL);
	// 	} 
	// }

	// Recognizer for floating point numbers --

	// TODO

	// // Recognizer for strings --

	// public void recint_string() { /* NOOP */ }
	// public void reccomp_string() { /* TODO sliteral */ }
	// public void recpost_string() { /* TODO compile code to compile a sliteral */ }

	// public void rec_string() {
	// 	int l = pop();
	// 	int a = pop();
	// 	if (cfetch(a) == '"') {
	// 		// Input buffer must be parsed until matching " or end of line
	// 		store(IPOS, (a - ibuf) + 1);
	// 		push(ibuf + (fetch(IPOS) * CHAR));
	// 		parse('"');
	// 		place(0, pick(0) - 1);
	// 		push(RECTYPE_STRING);
	// 	} else {
	// 		push(RECTYPE_NULL);
	// 	}
	// }

	// public void parse(char c) {
	// 	int ipos = fetch(IPOS);
	// 	push(ibuf + (ipos * CHAR));
	// 	while (ipos < ilen && cfetch(ibuf + (ipos * CHAR)) != c) ipos++;
	// 	push((ibuf + (ipos * CHAR) - pick(0)) / CHAR);
	// 	store(IPOS, ipos + (ipos < ilen ? 1 : 0));
	// }


	// -- Input/Output ----------------------------------------------------------

	// TODO All this is not needed for bootstrapping at all !!

	// For using custom KEY/EMIT/ACCEPT just do:
	// KEY = noname((vm) -> ....);
	// Any call to key will then be redirected to primitives(KEY)
	public int KEY = 0;
	public int EMIT = 0;

	public void emit() {
		if (EMIT != 0) do_prim(EMIT);
		else System.out.printf("%c", (char)pop());
	}

	public void key() {
		if (KEY != 0) do_prim(KEY);
		else {
			try {
				push(System.in.read());
			} catch (IOException e) {
				push(0);
			}
		}
	}

	public void cr() { push((int)'\n'); emit(); }

	public void type(int a, int l) {
		for (int i = a; i < a+(l*CHAR); i += CHAR) {
			push(cfetch(i));
			emit();
		}
	}

	public void type() { int l = pop(); type(pop(), l); }

	public void accept() {
		if (KEY == 0) {
			String s = System.console().readLine(); // This does not work with gradle run !!!!
			int l = pop();
			int a = pop();
			for (int i = 0; i < s.length() && i < l; i++) 
				cstore(a + (i * CHAR), s.charAt(i));
			push(Math.min(s.length(), l));
		} else {
			int l = pop();
			int a = pop();
			int n = 0;
			while (l > 0) {
				key();
				char c = (char)pop();
				if (c == 10 || c == 13) { 
					push(n); return;
				} else if (c == 127) { 
					if (n > 0) {
						n--;
						l++;
						a--;
						push(8); emit();
						push(32); emit();
						push(8); emit();
					}
				} else {
					cstore(a, c);
					n++;
					a++;
					l--;
				}
			}
		}
	}

	// tick is important but not needed for bootstrapping

	// Not for bootstrapping, I think

	public void comma() { comma(pop()); }
	public void ccomma() { ccomma((char)pop()); }

	public void compile() { compile(pop()); }
	public void literal() { literal(pop()); }




	// **************************************************************************

	// public void two_literal(long v) { compile(LIT); compile((int)(msp(v) >> 32)); compile(LIT); compile((int)lsp(v)); }
	// public void two_literal() { two_literal(dpop()); }

	// public int DOLOOP;

	public void ANS_bootstrap() {
		// This words are not required for bootstrapping the system, but to 
		// make it ANS Forth compatible.

		colon("NOOP", (vm) -> { });

		colon("DO", (vm) -> start_quotation()); set_immediate();
		colon("LOOP", (vm) -> { end_quotation(); compile(DOLOOP); }); set_immediate();

		// Stack shuffling

		colon("NIP", (vm) -> { swap(); drop(); });
		colon("TUCK", (vm) -> { swap(); over(); });
		colon("?DUP", (vm) -> { if (pick(0) != 0) dup(); });

		colon("2DROP", (vm) -> { drop(); drop(); });
		colon("2DUP", (vm) -> { over(); over(); });
		colon("2OVER", (vm) -> { push(pick(3)); push(pick(3)); });
		colon("2SWAP", (vm) -> { rot(); to_r(); rot(); from_r(); });

		colon("2R@", (vm) -> { two_from_r(); over(); over(); two_to_r(); });

		// Arithmetic

		colon("+", (vm) -> { place(1, pick(1) + pick(0)); drop(); });
		colon("-", (vm) -> { place(1, pick(1) - pick(0)); drop(); });
		colon("*", (vm) -> { place(1, pick(1) * pick(0)); drop(); });
		colon("/", (vm) -> { place(1, pick(1) / pick(0)); drop(); });
		colon("MOD", (vm) -> { place(1, pick(1) % pick(0)); drop(); });

		colon("*/MOD", (vm) -> { long n = lpop(); long d = lpop() * lpop(); push(d % n); push(d / n); });
		colon("*/", (vm) -> { long n = lpop(); long d = lpop() * lpop(); push(d / n); });
		colon("/MOD", (vm) -> { long n = lpop(); long d = lpop(); push(d % n); push(d / n); });

		colon("2*", (vm) -> place(0, pick(0) << 1));
		colon("1-", (vm) -> place(0, pick(0) - 1));
		colon("1+", (vm) -> place(0, pick(0) + 1));
		colon("2+", (vm) -> place(0, pick(0) + 2));

		colon("NEGATE", (vm) -> place(0, ~pick(0) + 1));

		// Comparison

		colon(">", (vm) -> { place(1, pick(1) > pick(0) ? -1 : 0); drop(); });
		colon("<", (vm) -> { place(1, pick(1) < pick(0) ? -1 : 0); drop(); });
		colon("=", (vm) -> { place(1, pick(1) == pick(0) ? -1 : 0); drop(); });
		colon(">=", (vm) -> { place(1, pick(1) >= pick(0) ? -1 : 0); drop(); });
		colon("<=", (vm) -> { place(1, pick(1) <= pick(0) ? -1 : 0); drop(); });
		colon("<>", (vm) -> { place(1, pick(1) != pick(0) ? -1 : 0); drop(); });

		colon("0<", (vm) -> place(0, pick(0) < 0 ? -1 : 0));
		colon("0=", (vm) -> place(0, pick(0) == 0 ? -1 : 0));
		colon("0>", (vm) -> place(0, pick(0) > 0 ? -1 : 0));
		colon("0<>", (vm) -> place(0, pick(0) != 0 ? -1 : 0));

		colon("U<", (vm) -> { long u1 = upop(); long u2 = upop(); push(Long.compareUnsigned(u2, u1) == -1 ? -1 : 0); });
		colon("U>", (vm) -> { long u1 = upop(); long u2 = upop(); push(Long.compareUnsigned(u2, u1) == 1 ? -1 : 0); });

		colon("WITHIN", (vm) -> { 
			long u1 = upop(); 
			long u2 = upop(); 
			long u3 = upop(); 
			push(Long.compareUnsigned((u3 - u2), (u1 - u2)) == -1 ? -1 : 0); 
		});

		colon("MIN", (vm) -> { int n1 = pop(); int n2 = pop(); push(n1 < n2 ? n1 : n2); });
		colon("MAX", (vm) -> { int n1 = pop(); int n2 = pop(); push(n1 > n2 ? n1 : n2); });

		// Bit

		colon("INVERT", (vm) -> place(0, ~pick(0)));
		colon("AND", (vm) -> { place(1, pick(1) & pick(0)); drop(); });
		colon("OR", (vm) -> { place(1, pick(1) | pick(0)); drop(); });
		colon("XOR", (vm) -> { place(1, pick(1) ^ pick(0)); drop(); });

		// Memory

		colon("CELL", (vm) -> push(CELL));
		colon("CHAR", (vm) -> push(CHAR));
		colon("CELLS", (vm) -> push(pop() * CELL));
		colon("CHARS", (vm) -> push(pop() * CHAR));
		colon("CELL+", (vm) -> push(pop() + CELL));
		colon("CELL-", (vm) -> push(pop() - CELL));
		colon("CHAR+", (vm) -> push(pop() + CHAR));
		colon("CHAR-", (vm) -> push(pop() - CHAR));

		colon("+!", (vm) -> { int a = pop(); int v = pop(); store(a, fetch(a) + v); });
		colon("0!", (vm) -> store(pop(), 0));
		colon("1+!", (vm) -> { int a = pop(); store(a, fetch(a) + 1); });
		colon("1-!", (vm) -> { int a = pop(); store(a, fetch(a) - 1); });

		colon("2!", (vm) -> { int a = pop(); int x2 = pop(); int x1 = pop(); store(a, x1); store(a + CELL, x2); });

		colon("ALIGNED", (vm) -> push(aligned(pop())));

		colon("CONSTANT", (vm) -> { create(); comma(); does((vmi) -> fetch()); });
		colon("VARIABLE", (vm) -> { create(); comma(0); });

		colon("2CONSTANT", (vm) -> { create(); comma(); comma(); does((vmi) -> two_fetch()); });
		colon("2VARIABLE", (vm) -> { create(); comma(0); comma(0); });

		colon("FALSE", (vm) -> push(0));
		colon("TRUE", (vm) -> push(~0));

		colon("ON", (vm) -> store(pop(), ~0));
		colon("OFF", (vm) -> store(pop(), 0));

		colon("LITERAL", (vm) -> { compile(LIT); comma(); }); set_immediate();

		colon("[']", (vm) -> { tick(); compile(LIT); comma(); }); set_immediate();
		colon("2LITERAL", (vm) -> { swap(); compile(LIT); comma(); compile(LIT); comma(); }); set_immediate();

		// TODO Should this two take into account postpone state or negative state
		// values?
		colon("[", (vm) -> store(STATE, 0));
		colon("]", (vm) -> store(STATE, 1));

	}

	public void Sloth_bootstrap() {
		// Non ANS words
		colon("DIP", (vm) -> { int xt = pop(); int v = pop(); eval(xt); push(v); });
		colon("2DIP", (vm) -> { int xt = pop(); int v1 = pop(); int v2 = pop(); eval(xt); push(v2); push(v1); });
		colon("3DIP", (vm) -> { int xt = pop(); int v1 = pop(); int v2 = pop(); int v3 = pop(); eval(xt); push(v3); push(v2); push(v1); });
		colon("4DIP", (vm) -> { int xt = pop(); int v1 = pop(); int v2 = pop(); int v3 = pop(); int v4 = pop(); eval(xt); push(v4); push(v3); push(v2); push(v1); });

		colon("KEEP", (vm) -> { int xt = pop(); int v = pick(0); eval(xt); push(v); });
		colon("2KEEP", (vm) -> { int xt = pop(); int v1 = pick(0); int v2 = pick(1); eval(xt); push(v2); push(v1); });
		colon("3KEEP", (vm) -> { int xt = pop(); int v1 = pick(0); int v2 = pick(1); int v3 = pick(2); eval(xt); push(v3); push(v2); push(v1); });
	}

	// -- Simple REPL -----------------------------------------------------------

	public void dump_stack() {
		System.out.printf("<%d> ", sp);
		for (int i = 0; i < sp; i++) System.out.printf("%d ", s[i]);
		System.out.println();
	}

	public void dump_memory(int a, int l) {
		// For reusing it...
		// if (fetch(DUMP) != 0) eval(DUMP); else ...
		for (int i = a; i < a + l;) {
			System.out.printf("%08X ", i);
			for (int j = 0; j < 4; j++, i += 2) System.out.printf("%04X ", (short)cfetch(i));
			System.out.printf(" ");
			for (int j = 0; j < 4; j++, i += 2) System.out.printf("%04X ", (short)cfetch(i));
			i -= 16;
			for (int j = 0; j < 4; j++, i += 2) {
				char c = cfetch(i);
				System.out.printf("%c", c < 32 ? '.' : c);
			}
			System.out.printf(" ");
			for (int j = 0; j < 4; j++, i += 2) {
				char c = cfetch(i);
				System.out.printf("%c", c < 32 ? '.' : c);
			}
			System.out.println();
		}
	}

	public static void main(String[] args) {
		Sloth x = new Sloth();
		// x.bootstrap_vm(); // TODO This could be called on constructor?

		// x.store(0, x.LIT);
		// x.store(4, 2);
		// x.store(8, x.LIT);
		// x.store(12, 3);
		// x.store(16, x.ADD);
		// x.store(20, x.EXIT);

		// x.ip = 0;
		// x.inner();

		// x.dump_stack();

		// ---

		x.bootstrap();
	 	try {
	 		URL url = Thread.currentThread().getContextClassLoader().getResource("sloth.4th");
	 		x.include(url.getFile());
	 	} catch(Exception e) {
	 		e.printStackTrace();
			System.exit(-1);
	 	}

		// x.ANS_bootstrap();
		// x.Sloth_bootstrap();

		// System.out.println("  __.  .    _.  ... .  .");
		// System.out.println(" /___  |   /  \\  |  |..|");
		// System.out.println(" .__/  |__ \\._/  |  |  |");

		System.out.println("SLOTH (SLOw forTH) for the JVM");
		System.out.println("v1.0.0 jordipbou, 2024");

		x.quit();

		// ---

		// x.evaluate("fIb");

		// x.dump_stack();

		////x.eval(x.find_name("FIB"));
		//x.push(x.xt(x.find_name("FIB")));

		//x.execute();

		//x.dump_stack();

		//x.colon("CONSTANT", (vm) -> { vm.create(); vm.comma(); vm.does((vmi) -> vmi.fetch()); });

		//x.push(19);

		//x.str_to_transient("TEST");
		//x.dump_stack();
		//x.ilen = x.pop();
		//x.ibuf = x.pop();
		//x.store(x.IPOS, 0);

		//x.eval(x.xt(x.find_name("CONSTANT")));

		//System.out.printf("LATEST NAME: "); x.type(x.name(x.latest()), x.namelen(x.latest())); System.out.println();

		//x.dump_stack();

		//x.push(x.dt(x.find_name("TEST")));
		//x.eval(x.xt(x.find_name("TEST")));

		//x.dump_stack();
		

		// x.store(0, -1);
		// x.cstore(16, 'Z');
		// x.cstore(32, (char)182);
		// x.dump_memory(0, 128);

		// x.noname((vm) -> vm.exit());
		// x.noname((vm) -> vm.push(vm.token()));
		// x.noname((vm) -> vm.add());
		// x.noname((vm) -> vm.fib());

		// x.store(0, -2);
		// x.store(4, 36);
		// x.store(8, -4);
		// x.store(12, -1);

		// x.store(0, -2);
		// x.store(4, 11);
		// x.store(8, -2);
		// x.store(12, 13);
		// x.store(16, -3);
		// x.store(20, -1);

		// x.dump_memory(0, 32);

		// x.eval(0);

		// x.dump_stack();

		// x.evaluate("quit");
		// try {
		// 	URL url = Thread.currentThread().getContextClassLoader().getResource("sloth.4th");
		// 	x.include(url.getFile());
		// } catch(IOException e) {
		//  	e.printStackTrace();
		// } catch(Exception e) {
		// 	e.printStackTrace();
		// }
	}


	// // --------------------------------------------------------------------------

	// // Constructor

	// public Sloth() {
	// 	s = new int[256];
	// 	sp = 0;
	// 	a = new int[256];
	// 	ap = 0;
	// 	f = new double[16];
	// 	fp = 0;
	// 	o = new Object[256];
	// 	op = 0;
	// 	mem = ByteBuffer.allocateDirect(65536);
	// 	omem = new Object[65536 >> 3];
	// 	// store(STATE, 0);
	// 	// here(0);
	// 	// there(MARGIN);
	// 	// ip = -1;
	// 	// primitives = new ArrayList<Consumer<Sloth>>();
	// }

	// // -- Data stack ------------------------------------------------------------

	// public int[] s;			// Data stack
	// public int sp;			// Data stack pointer
	// 
	// // Helpers to get the most/least significant bits from a long integer, 
	// // used for working with double cell numbers which are a requirement for
	// // ANS Forth (even when not implementing the optional Double-Number word
	// // set).
	// public long msp(long v) { return (v & 0xFFFFFFFF00000000L); }
	// public long lsp(long v) { return (v & 0x00000000FFFFFFFFL); }

	// // Push/pop variants
	// public void dpush(long v) { push(v); push(v >> 32); }
	// public void push(long v) { push((int)lsp(v)); }
	// public void push(int v) { s[sp++] = v; }
	// public long dpop() { long b = lpop(); return msp(b << 32) + lsp(lpop()); }
	// public long lpop() { return (long)s[--sp]; }
	// public long upop() { return Integer.toUnsignedLong(s[--sp]); }
	// public long udpop() { long b = upop(); return msp(b << 32) + lsp(upop()); }
	// public int pop() { return s[--sp]; }

	// // Pick from the stack
	// public int pick(int a) { return s[sp - a - 1]; }
	// public void place(int a, int v) { s[sp - a - 1] = v; }

	// // -- Address stack ---------------------------------------------------------

	// public int[] a;			// Return stack
	// public int ap;			// Return stack pointer

	// public void apush(int v) { a[ap++] = v; }
	// public int apop() { return a[--ap]; }

	// public void to_a() { apush(pop()); }
	// public void from_a() { push(apop()); }

	// // -- Floating point stack --------------------------------------------------

	// public double[] f;	// Floating point stack
	// public int fp;			// Floating point stack pointer

	// public void fpush(double v) { f[fp++] = v; }
	// public double fpop() { return f[--fp]; }

	// // -- Object stack ----------------------------------------------------------

	// public Object[] o;	// Object stack
	// public int op;			// Object stack pointer

	// public void opush(Object v) { o[op++] = v; }
	// public Object opop() { return o[--op]; }

	// // -- Dictionary ------------------------------------------------------------

	// public static int MARGIN = 512;

	// public ByteBuffer mem;
	// public int dp;	// Dictionary pointer
	// public int tp;	// Transient memory pointer

	// public Object[] omem;

	// public int fetch(int a) { return mem.getInt(a); }
	// public void store(int a, int v) { mem.putInt(a, v); }
	// public char cfetch(int a) { return mem.getChar(a); }
	// public void cstore(int a, char v) { mem.putChar(a, v); }

	// public double ffetch(int a) { return mem.getDouble(a); }
	// public void fstore(int a, double v) { mem.putDouble(a, v); }

	// public Object ofetch(int a) { return omem[a >> 3]; }
	// public void ostore(int a, Object v) { omem[a >> 3] = v; }

	// // -- Contiguous memory

	// public int here() { return dp; }
	// public void here(int v) { dp = v; }
	// public void allot(int v) { here(here() + v); }
	// public void align() { here((here() + (CELL - 1)) & ~(CELL - 1)); }

	// // -- Transient memory

	// public int there() { return tp; }
	// public void there(int v) { tp = v; }
	// public int tallot(int v) { 
	// 	if (there() < (here() + MARGIN)) there(here() + MARGIN);
	// 	if ((there() + v) > mem.capacity()) there(here() + MARGIN);
	// 	// if ((there() + v) > mem.capacity()) throw exception ??!!
	// 	int x = there();
	// 	there(there() + v);
	// 	return x;
	// }
	// public void talign() { there((there() + (CELL - 1)) & ~(CELL - 1)); }

	// // -- Inner interpreter -----------------------------------------------------

	// public int ip;	// Instruction pointer

	// public List<Consumer<Sloth>> primitives;

	// public int token() { int v = fetch(ip); ip += CELL; return v; }
	// public boolean valid_ip() { return ip >= 0 && ip < mem.capacity(); }
	// public boolean tail() { return !valid_ip() || fetch(ip) == EXIT; }
	// public void do_prim(int p) { primitives.get(-1 - p).accept(this); }
	// // NOTE: Tail call optimization has failed when 2R> was implemented directly in SLOTH.
	// // It also fails with words that end on r> when executed in interpretation mode in the REPL.
	// public void call(int q) { if (!tail()) apush(ip); ip = q; }
	// public void execute(int q) { if (q < 0) do_prim(q); else call(q); }
	// public void inner() {	int t = ap; while (t <= ap && valid_ip()) { /* trace(); System.out.println(); */ execute(token()); } }
	// public void eval(int q) { execute(q); inner(); }
	// public void exit() { if (ap > 0) ip = apop(); else ip = -1; }

	// // // Helpers words used on development
	// // // To be removed, relocated or cleaned ***********

	// // public void trace() {
	// // 	System.out.printf("[%d] ", fetch(STATE));
	// // 	System.out.printf("IP::%d ", ip);
	// // 	xt_to_name(fetch(ip)); type(); System.out.printf(" ");
	// // 	dump_stack();
	// // }

	// // public void xt_to_name(int v) {
	// // 	int w = latest();
	// // 	while (w != 0) {
	// // 		if (xt(w) == v) { push(name(w)); push(namelen(w)); return; }
	// // 		w = link(w);
	// // 	}
	// // 	push(0); push(0);
	// // }

	// // *************

	// // TODO Input buffer is primitive, I think

	// // !! End of Virtual Machine implementation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	// // -- Primitives to be accessed from Java -----------------------------------

	// public int EXIT;
	// public int LIT;

	// // -- Forth state -----------------------------------------------------------

	// public int STATE;
	// public int BASE;
	// public int SOURCE_ID;
	// public int IPOS;
	// public int FORTH_RECOGNIZER;

	// // -- Forth words -----------------------------------------------------------

	// public void drop() { pop(); }
	// public void dup() { push(pick(0)); }
	// public void over() { push(pick(1)); }
	// public void swap() { int a = pop(); int b = pop(); push(a); push(b); };
	// // public void rot() .....

	// public void two_drop() { pop(); pop(); }

	// public void parse_name() {
	// 	int ipos = fetch(IPOS);
	// 	while (ipos < ilen && cfetch(ibuf + (ipos * CHAR)) < 33) ipos++;
	// 	push(ibuf + (ipos * CHAR));
	// 	while (ipos < ilen && cfetch(ibuf + (ipos * CHAR)) > 32) ipos++;
	// 	push((ibuf + (ipos * CHAR) - pick(0)) / CHAR);
	// 	store(IPOS, ipos + (ipos < ilen ? 1 : 0));
	// }


	// //// If state is negative, everything is compiled to transient memory.
	// //// This will allow using immediate words like IF or [: in interpret
	// //// mode.
	// //public void comma(int v) { 
	// //	if (fetch(STATE) >= 0) {
	// //		store(here(), v); allot(CELL); 
	// //	} else {
	// //		store(there(), v); tallot(CELL);
	// //	}
	// //}
	// //public void ccomma(char v) { 
	// //	if (fetch(STATE) >= 0) {
	// //		cstore(here(), v); allot(CHAR);
	// //	} else {
	// //		cstore(there(), v); tallot(CHAR);
	// //	}
	// //}

	// //public void compile(int v) { comma(v); }
	// //public void literal(int v) { compile(LIT); compile(v); }

	// //// Copies a string object content to transient memory

	// //public void str_to_transient(String str) {
	// //	int t = tallot(str.length());
	// //	push(t);
	// //	for (int i = 0; i < str.length(); i++) cstore(t + (i * CHAR), str.charAt(i));
	// //	push(str.length());
	// //}

	// //// Creates a string object from a char addressed array from memory

	// //public String data_to_str(int a, int u) {
	// //	StringBuilder sb = new StringBuilder();
	// //	for (int i = 0; i < u; i++) sb.append(cfetch(a + (i * CHAR)));
	// //	return sb.toString();
	// //}

	// //// -- Forth state -----------------------------------------------------------

	// //public static int LATEST = 0*CELL;
	// //public static int LATESTXT = 1*CELL;
	// //public static int STATE = 2*CELL;
	// //public static int SOURCE_ID = 3*CELL; 
	// //public static int IPOS = 4*CELL;
	// //public static int BASE = 5*CELL;
	// //public static int CURRENT = 6*CELL;

	// //// Vectored words 

	// //public static int EMIT = 7*CELL;
	// //public static int KEY = 8*CELL;
	// //public static int ACCEPT = 9*CELL;
	// //public static int INTERPRET = 10*CELL;

	// //public static int LAST_VAR = 11*CELL;

	// //// Primitives that need to be compiled from Java code

	// //public static int EXIT;
	// //public static int LIT;
	// //public static int doDOES;
	// //public static int BLOCK;
	// //public static int COMPILE;
	// //public static int BRANCH;
	// //public static int zBRANCH;

	// //// -- Words -----------------------------------------------------------------

	// //public static char HIDDEN = 1;
	// //public static char COLON = 2;
	// //public static char IMMEDIATE = 4;

	// //public int latest() { return fetch(LATEST); }
	// //public void latest(int v) { store(LATEST, v); }

	// //public int latestxt() { return fetch(LATESTXT); }
	// //public void latestxt(int v) { store(LATESTXT, v); }

	// //public int xt(int w) { return fetch(w + CELL); }
	// //public void xt(int w, int v) { store(w + CELL, v); }

	// //public int dt(int w) { return fetch(w + CELL + CELL); }
	// //public void dt(int w, int v) { store(w + CELL + CELL, v); }

	// //public int link(int w) { return fetch(w); }

	// //public int wordlist(int w) { return fetch(w + CELL + CELL + CELL); }
	// //public void wordlist(int w, int v) { store(w + CELL + CELL + CELL, v); }

	// //public char flags(int w) { return cfetch(w + CELL + CELL + CELL + CELL); }
	// //public void flags(int w, char v) { cstore(w + CELL + CELL + CELL + CELL, v); }
	// //public void set_flag(int w, char v) { flags(w, (char)(flags(w) | v)); }
	// //public void unset_flag(int w, char v) { flags(w, (char)(flags(w) & ~v)); }
	// //public boolean has_flag(int w, char v) { return (flags(w) & v) == v; }

	// //public char namelen(int w) { return cfetch(w + CELL + CELL + CELL + CELL + CHAR); }
	// //public int name(int w) { return w + CELL + CELL + CELL + CELL + CHAR + CHAR; }

	// //public void immediate() { set_flag(latest(), (char)(flags(latest()) | IMMEDIATE)); }

	// //public void header(String s) { str_to_transient(s); header(); }

	// //public void header() {
	// //	int l = pop();
	// //	int a = pop();
	// //	align();
	// //	int w = here();																				// Address of NT/XT
	// //	comma(latest()); latest(w);														// LINK
	// //	comma(0);																							// XT
	// //	comma(0);																							// DT
	// //	comma(fetch(CURRENT));																// WORDLIST
	// //	ccomma((char)0);																			// FLAGS
	// //	ccomma((char)l);																			// NAME LENGTH
	// //	for (int i = 0; i < l; i++) ccomma(cfetch(a + (i * CHAR)));	// Name
	// //	align();
	// //	dt(latest(), here());
	// //}

	// //public boolean compare_without_case(int n, int l, int w) {
	// //	if (l != namelen(w)) return false;
	// //	for (int i = 0; i < l; i++) {
	// //		char a = cfetch(n + (i * CHAR));
	// //		char b = cfetch(name(w) + (i * CHAR));
	// //		if (a >= 97 && a <= 122) a -= 32;
	// //		if (b >= 97 && b <= 122) b-= 32;
	// //		if (a != b) return false;
	// //	}
	// //	return true;
	// //}

	// //public boolean in_search_order(int w) {
	// //	for (int i = wordlists_ptr - 1; i >= 0; i--) {
	// //		if (wordlist(w) == wordlists[i]) return true;
	// //	}
	// //	return false;
	// //}

	// //public void find_name() {
	// //	int l = pop(); 
	// //	int n = pop();
	// //	int w = latest();
	// //	while (w != 0) {
	// //		if (compare_without_case(n, l, w) && !has_flag(w, HIDDEN) && in_search_order(w)) break;
	// //		w = link(w);
	// //	}
	// //	push(w);
	// //}

	// //// --------------------------------------------------------------------------

	// //// Input buffer

	// //public int ibuf;
	// //public int ilen;

	// //public String last_dir = "";
	// //public BufferedReader last_buffered_reader;

	// //public void key() {
	// //	if (fetch(KEY) != 0) eval(fetch(KEY));
	// //	else {
	// //		try {
	// //			push(System.in.read());
	// //		} catch (IOException e) {
	// //			push(0);
	// //		}
	// //	}
	// //}

	// //public void emit() {
	// //	if (fetch(EMIT) != 0) eval(fetch(EMIT));
	// //	else System.out.printf("%c", (char)pop());
	// //}

	// //public void accept() {
	// //	if (fetch(ACCEPT) != 0) eval(fetch(ACCEPT));
	// //	else if (fetch(KEY) == 0) {
	// //		String s = System.console().readLine();
	// //		int l = pop();
	// //		int a = pop();
	// //		for (int i = 0; i < s.length() && i < l; i++) 
	// //			cstore(a + (i * CHAR), s.charAt(i));
	// //		push(s.length());
	// //	} else {
	// //		int l = pop();
	// //		int a = pop();
	// //		int n = 0;
	// //		while (l > 0) {
	// //			key();
	// //			char c = (char)pop();
	// //			if (c == 10 || c == 13) { 
	// //				push(n); return;
	// //			} else if (c == 127) { 
	// //				if (n > 0) {
	// //					n--;
	// //					l++;
	// //					a--;
	// //					push(8); emit();
	// //					push(32); emit();
	// //					push(8); emit();
	// //				}
	// //			} else {
	// //				cstore(a, c);
	// //				n++;
	// //				a++;
	// //				l--;
	// //			}
	// //		}
	// //	}
	// //}

	// //public void type() {
	// //	int l = pop();
	// //	int a = pop();
	// //	for (int i = 0; i < l; i++) { 
	// //		push(cfetch(a + (i * CHAR))); emit(); 
	// //	}
	// //}

	// //public void source_id() { push(SOURCE_ID); }
	// //public void refill() {
	// //	switch (fetch(SOURCE_ID)) {
	// //		case -1: push(-1); break;
	// //		case 0: 
	// //			ibuf = tallot(80);
	// //			push(ibuf); 
	// //			push(80); 
	// //			eval(fetch(ACCEPT)); 
	// //			ilen = pop();
	// //			store(IPOS, 0);
	// //			push(-1); 
	// //			break;
	// //		default: 
	// //			try {
	// //				str_to_transient(last_buffered_reader.readLine());
	// //				ilen = pop();
	// //				ibuf = pop();
	// //				store(IPOS, 0);
	// //				push(-1);
	// //			} catch (Exception e) {
	// //				push(0);
	// //			}
	// //	}
	// //}

	// //public void include(String filename) throws FileNotFoundException, IOException {
	// // 	File file = new File(filename);
	// //	if (!file.exists()) {
	// //		file = new File(last_dir + filename);
	// //		if (!file.exists()) {
	// //			throw new FileNotFoundException();
	// //		}
	// //	}

	// //	String prevDir = last_dir;
	// //	last_dir = file.getAbsolutePath().replace(file.getName(), "");

	// //	BufferedReader prevReader = last_buffered_reader;
	// // 	last_buffered_reader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));

	// //	int last_source_id = fetch(SOURCE_ID);
	// //	store(SOURCE_ID, 1);

	// // 	while (true) {
	// // 		String line = last_buffered_reader.readLine();
	// // 		if (line == null) break;
	// //		System.out.println(line);
	// //		str_to_transient(line);
	// //		ilen = pop();
	// //		ibuf = pop();
	// //		store(IPOS, 0);
	// //		try {
	// //			interpret();
	// //		} catch(Exception e) {
	// //			// TODO Exceptions should be managed by the inner interpreter
	// //			System.out.printf("Exception on line: [%s]\n", line);
	// //			e.printStackTrace();
	// //			break;
	// //		}
	// // 	}

	// //	store(SOURCE_ID, last_source_id);
	// //	last_buffered_reader.close();
	// //	last_buffered_reader = prevReader;
	// //	last_dir = prevDir;
	// //}

	// //// -- Parsing ---------------------------------------------------------------

	// //// --------------------------------------------------------------------------

	// //// Definitions

	// //// Creates a word only if it does not exist in the dictionary
	// //// Useful for bootstrapping
	// //public void maybe_colon() { 
	// //	parse_name();
	// //	find_name(); 
	// //	store(IPOS, pop() == 0 ? 1 : ilen); 
	// //}

	// //public void colon() {
	// //	parse_name();
	// //	header();
	// //	xt(latest(), dt(latest()));
	// //	latestxt(xt(latest()));
	// //	set_flag(latest(), COLON);
	// //	set_flag(latest(), HIDDEN);
	// //	store(STATE, 1);
	// //}

	// //public void semicolon() { 
	// //	compile(EXIT); 
	// //	store(STATE, 0); 
	// //	// If latestxt is not a :NONAME definition, remove its hidden flag
	// //	if (xt(latest()) == latestxt())	
	// //		unset_flag(latest(), HIDDEN); 
	// //};
	// //public void create() { parse_name(); header(); }
	// //public void does() { literal(here() + 16); compile(doDOES); compile(EXIT); }

	// //public void noname() {
	// //	align();
	// //	push(here());
	// //	latestxt(here());
	// //	store(STATE, 1);
	// //}

	// //public void start_quotation() {
	// //	if (fetch(STATE) > 0) {
	// //		align();
	// //		compile(BLOCK);
	// //		push(here());
	// //		comma(0);
	// //		latestxt(here());
	// //		store(STATE, fetch(STATE) + 1);
	// //	} else if (fetch(STATE) == 0) {
	// //		push(here());
	// //		latestxt(here());
	// //		store(STATE, fetch(STATE) - 1);
	// //	} else {
	// //		talign();
	// //		compile(BLOCK);
	// //		push(there());
	// //		comma(0);
	// //		latestxt(there());
	// //		store(STATE, fetch(STATE) - 1);
	// //	}
	// //}

	// //public void end_quotation() {
	// //	compile(EXIT);
	// //	if (fetch(STATE) > 0) {
	// //		int mark = pop();
	// //		store(mark, here() - mark);
	// //		store(STATE, fetch(STATE) - 1);
	// //	} else {
	// //		int tmark = pop();
	// //		store(tmark, there() - tmark);
	// //		store(STATE, fetch(STATE) + 1);
	// //	}
	// //}

	// //// -- Outer interpreter and evaluation --------------------------------------

	// //public void evaluate(String str) { str_to_transient(str); evaluate(); }
	// //public void evaluate() {
	// //	int l = ilen;
	// //	int b = ibuf;
	// //	int p = fetch(IPOS);
	// //	int source_id = fetch(SOURCE_ID);
	// //	ilen = pop();
	// //	ibuf = pop();
	// //	store(IPOS, 0);
	// //	store(SOURCE_ID, -1);
	// //	interpret();
	// //	store(SOURCE_ID, source_id);
	// //	store(IPOS, p);
	// //	ibuf = b;
	// //	ilen = l;
	// //}

	// //public void interpret() {
	// //}

	// // // TODO Add recognizers to the interpreter directly here !!! (Why not?!)
	// // public void interpret() {
	// // 	if (fetch(INTERPRET) != 0) eval(fetch(INTERPRET));
	// // 	else {
	// // 		while (true) {
	// // 			parse_name(); 
	// // 			System.out.printf("TOKEN ["); over(); over(); type(); System.out.printf("]\n");
	// // 			if (s[sp - 1] == 0) { pop(); pop(); return; }
	// // 			int caddr = s[sp - 2]; int u = s[sp - 1];
	// // 			find_name(); int w = pop();
	// // 			if (w != 0) {
	// // 				System.out.printf("WORD FOUND W::%d XT(W)::%d DT(W)::%d\n", w, xt(w), dt(w));
	// // 				if (fetch(STATE) == 0 || has_flag(w, IMMEDIATE)) {
	// // 					System.out.println("INTERPRETING");
	// // 					if (!has_flag(w, COLON)) push(dt(w));
	// // 					if (xt(w) != 0) eval(xt(w));
	// // 				} else {
	// // 					System.out.println("COMPILING");
	// // 					if (!(has_flag(w, COLON))) { literal(dt(w)); } // comma(LIT); comma(dt(w)); }
	// // 					if (xt(w) != 0) compile(xt(w)); // comma(xt(w));
	// // 				}
	// // 			} else {
	// // 				System.out.println("WORD NOT FOUND, CONVERTING TO NUMBER");
	// // 				StringBuffer sb = new StringBuffer();
	// // 				for (int i = 0; i < u; i++) sb.append(cfetch(caddr + (i * CHAR)));
	// // 				int n = (int)Long.parseLong(sb.toString(), fetch(BASE));
	// // 				if (fetch(STATE) == 0) push(n);
	// // 				else { comma(LIT); comma(n); }
	// // 			}
	// // 		}
	// // 	}
	// // }

	// // // --------------------------------------------------------------------------

	// // // Include



	// // // --------------------------------------------------------------------------

	// // // Bootstrapping

	// // public void primitive(String s, Consumer<Sloth> c) {
	// // 	primitives.add(c);
	// // 	header(s);
	// // 	xt(latest(), 0 - primitives.size());
	// // 	set_flag(latest(), COLON);
	// // }

	// // public void bootstrap() {
	// // 	allot(LAST_VAR);
	// // 	store(LATEST, 0);
	// // 	store(STATE, 0);
	// // 	store(SOURCE_ID, 0);
	// // 	store(IPOS, 0);
	// // 	store(BASE, 10);
	// // 	store(CURRENT, 1);

	// // 	store(EMIT, 0);
	// // 	store(KEY, 0);
	// // 	store(ACCEPT, 0);
	// // 	store(INTERPRET, 0);

	// // 	// This primitives are used inside Java code. We to store
	// // 	// its xt on variables.
	// // 	primitive("EXIT", (vm) -> exit());
	// // 	EXIT = xt(latest());
	// // 	primitive("LIT", (vm) -> push(token()));
	// // 	LIT = xt(latest());
	// // 	primitive("doDOES", (vm) -> xt(latest(), pop()));
	// // 	doDOES = xt(latest());
	// // 	primitive("COMPILE,", (vm) -> comma(pop()));
	// // 	COMPILE = xt(latest());

	// // 	primitive("BRANCH", (vm) -> ip += token());
	// // 	BRANCH = xt(latest());
	// // 	primitive("?BRANCH", (vm) -> { if (pop() == 0) ip += token(); else ip += CELL; });
	// // 	zBRANCH = xt(latest());

	// // 	primitive("BLOCK", (vm) -> { int v = token(); push(ip); ip += v - CELL; });
	// // 	BLOCK = xt(latest());

	// // 	primitive("doSTRING", (vm) -> { int l = token(); push(ip); push(l); ip += (l + (CELL - 1)) & ~(CELL - 1);	});

	// // 	primitive("EXECUTE", (vm) -> execute(pop()));
	// // 	primitive("RECURSE", (vm) -> compile(latestxt()));
	// // 	primitive(":NONAME", (vm) -> { push(here()); latestxt(here()); store(STATE, 1); });
	// // 	primitive("BYE", (vm) -> System.exit(0));

	// // 	// Forth state ------------------------------------------------------------

	// // 	primitive("LATEST", (vm) -> push(LATEST));
	// // 	primitive("LATESTXT", (vm) -> push(LATESTXT));
	// // 	primitive("STATE", (vm) -> push(STATE));
	// // 	primitive("HERE", (vm) -> push(HERE));
	// // 	primitive("THERE", (vm) -> push(THERE));
	// // 	primitive("SOURCE-ID!", (vm) -> store(SOURCE_ID, pop()));
	// // 	primitive("SOURCE", (vm) -> { push(ibuf); push(ilen); });
	// // 	primitive(">IN", (vm) -> push(IPOS));
	// // 	primitive("BASE", (vm) -> push(BASE));
	// // 	primitive("CURRENT", (vm) -> push(CURRENT));

	// // 	primitive("(INTERPRET)", (vm) -> push(INTERPRET));

	// // 	// Return stack manipulation ----------------------------------------------

	// // 	primitive("RP@", (vm) -> push(rp));
	// // 	primitive("RP!", (vm) -> rp = pop());
	// // 	primitive(">R", (vm) -> apush(pop()));
	// // 	primitive("R>", (vm) -> push(apop()));

	// // 	// Data stack manipulation ------------------------------------------------

	// // 	primitive("SP@", (vm) -> push(sp));
	// // 	primitive("SP!", (vm) -> sp = pop());
	// // 	primitive("DROP", (vm) -> pop());
	// // 	primitive("DUP", (vm) -> dup());
	// // 	primitive("OVER", (vm) -> over());
	// // 	primitive("SWAP", (vm) -> swap());
	// // 	primitive("PICK", (vm) -> push(P(pop())));

	// // 	// Memory operations ------------------------------------------------------

	// // 	primitive("HERE", (vm) -> push(here()));
	// // 	primitive("ALLOT", (vm)-> allot(pop()));
	// // 	primitive("UNUSED", (vm) -> push(mem.capacity() - here()));
	// // 	primitive("@", (vm) -> push(fetch(pop())));
	// // 	primitive("!", (vm) -> { int a = pop(); int v = pop(); store(a, v); });
	// // 	primitive("C@", (vm) -> push(cfetch(pop())));
	// // 	primitive("C!", (vm) -> { int a = pop(); int v = pop(); cstore(a, (char)v); });
	// // 	primitive("CELLS", (vm) -> push(pop() * CELL));
	// // 	primitive("CHARS", (vm) -> push(pop() * CHAR));

	// // 	// Bit operations ---------------------------------------------------------

	// // 	primitive("0<", (vm) -> { int v = pop(); push(v < 0 ? -1 : 0); });
	// // 	primitive("AND", (vm) -> { int v = pop(); int w = pop(); push(w & v); });
	// // 	primitive("INVERT", (vm) -> { int v = pop(); push(~v); });
	// // 	primitive("RSHIFT", (vm) -> { int a = pop(); int b = pop(); push(b >>> a); });
	// // 	primitive("2/", (vm) -> { int a = pop(); push(a >> 1); });

	// // 	// Required Arithmetic operations -----------------------------------------

	// // 	primitive("-", (vm) -> { int a = pop(); int b = pop(); push(b - a); });
	// // 	primitive("*/MOD", (vm) -> { long n = lpop(); long d = lpop() * lpop(); push(d % n); push(d / n); });
	// // 	primitive("UM*", (vm) -> { long r = upop() * upop(); dpush(r); });
	// // 	primitive("UM/MOD", (vm) -> { long u = upop(); long d = dpop(); push(Long.remainderUnsigned(d, u)); push(Long.divideUnsigned(d, u)); });

	// // 	// Additional Arithmetic operations ---------------------------------------

	// // 	primitive("+", (vm) -> { int a = pop(); int b = pop(); push(b + a); });

	// // 	// Definitions ------------------------------------------------------------

	// // 	primitive("?:", (vm) -> maybe_colon());
	// // 	primitive(":", (vm) -> colon());
	// // 	primitive(";", (vm) -> semicolon()); immediate(); 
	// // 	primitive("CREATE", (vm) -> create());
	// // 	primitive("DOES>", (vm) -> does());	immediate();
	// // 	primitive("IMMEDIATE", (vm) -> immediate());
	// // 	primitive("'", (vm) -> { parse_name(); find_name(); push(xt(pop())); });
	// // 	primitive("POSTPONE", (vm) -> {
	// // 		parse_name();
	// // 		find_name();
	// // 		int w = pop();
	// // 		if (has_flag(w, IMMEDIATE)) {	compile(xt(w));	} 
	// // 		else { literal(xt(w)); compile(COMPILE);	}
	// // 	}); immediate();

	// // 	// primitive("IMMEDIATE-FLAG", (vm) -> push(IMMEDIATE));
	// // 	// primitive("COLON-FLAG", (vm) -> push(COLON));
	// // 	// primitive("HIDDEN-FLAG", (vm) -> push(HIDDEN));

	// // 	primitive("NT>LINK", (vm) -> link(pop()));
	// // 	primitive("NT>XT", (vm) -> xt(pop()));
	// // 	primitive("NT>DT", (vm) -> dt(pop()));
	// // 	primitive("NT>WORDLIST", (vm) -> wordlist(pop()));
	// // 	primitive("NT>FLAGS", (vm) -> flags(pop()));
	// // 	primitive("NT>NAME", (vm) -> { int v = pop(); push(name(v)); push(namelen(v)); });
	// // 	primitive("NAME>STRING", (vm) -> { int v = pop(); push(name(v)); push(namelen(v)); });

	// // 	primitive("IMMEDIATE?", (vm) -> has_flag(pop(), IMMEDIATE));
	// // 	primitive("COLON?", (vm) -> has_flag(pop(), COLON));
	// // 	primitive("HIDDEN?", (vm) -> has_flag(pop(), HIDDEN));

	// // 	// Evaluation -------------------------------------------------------------

	// // 	primitive("EVALUATE", (vm) -> evaluate());
	// // 	primitive("INCLUDED", (vm) -> { 
	// // 		int l = pop(); 
	// // 		int a = pop(); 

	// // 		// TODO: Manage exceptions
	// // 		try {
	// // 			include(data_to_str(a, l)); 
	// // 		} catch(Exception e) {
	// // 			e.printStackTrace();
	// // 		}
	// // 	});

	// // 	// Control structures -----------------------------------------------------

	// // 	// This two are only needed for DO/LOOP implementation, but maybe DO/LOOP should
	// // 	// be a primitive.
	// // 	primitive(">MARK", (vm) -> { push(here()); comma(0); });
	// // 	primitive(">>RESOLVE", (vm) -> store(pop(), here()));

	// // 	primitive("AHEAD", (vm) -> { compile(BRANCH); push(here()); comma(0); }); immediate();
	// // 	primitive("IF", (vm) -> { compile(zBRANCH); push(here()); comma(0); }); immediate();
	// // 	primitive("THEN", (vm) -> { int a = pop(); store(a, here() - a); }); immediate();

	// // 	primitive("BEGIN", (vm) -> push(here())); immediate();
	// // 	primitive("UNTIL", (vm) -> { compile(zBRANCH); comma(pop() - here()); }); immediate();
	// // 	primitive("AGAIN", (vm) -> { compile(BRANCH); comma(pop() - here()); }); immediate();

	// // 	// Quotations -------------------------------------------------------------

	// // 	primitive("[:", (vm) -> { compile(BLOCK); push(here()); comma(0); }); immediate();
	// // 	primitive(";]", (vm) -> { compile(EXIT); int a = pop(); store(a, here() - a); }); immediate();

	// // 	// Input/output -----------------------------------------------------------

	// // 	// TODO These two must be deferred ?
	// // 	primitive("EMIT", (vm) -> emit());
	// // 	primitive("KEY", (vm) -> key());
	// // 	primitive("REFILL", (vm) -> refill());
	// // 	primitive("ACCEPT", (vm) -> accept());
	// // 	primitive("(ACCEPT)", (vm) -> push(ACCEPT));

	// // 	// Tools ------------------------------------------------------------------

	// // 	primitive(".S", (vm) -> dump_stack());

	// // 	// Error management -------------------------------------------------------
	// // 
	// // 	// TODO CATCH THROW
	// // }

	// // // --------------------------------------------------------------------------

	// // // Utilities

	// // public void dump_stack() {
	// // 	// Temporary, should use EMIT/TYPE
	// // 	System.out.printf("<%d> ", sp);
	// // 	for (int i = 0; i < sp; i++) System.out.printf("%d ", s[i]);
	// // }

	// // // --------------------------------------------------------------------------

	// // // Simple REPL

	// // public static void main(String[] args) {
	// // 	Sloth x = new Sloth();
	// // 	x.bootstrap();

	// // 	try {
	// // 		URL url = Thread.currentThread().getContextClassLoader().getResource("sloth.4th");
	// // 		x.include(url.getFile());
	// // 	} catch(IOException e) {
	// // 	 	e.printStackTrace();
	// // 	} catch(Exception e) {
	// // 		e.printStackTrace();
	// // 	}
	// // }
}
