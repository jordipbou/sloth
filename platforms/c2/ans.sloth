: ?: 32 word find swap drop 0 = 1 + source swap drop over * swap 1 swap - + >in ! ;

?: \ source >in ! drop ; immediate

\ End of line comments can be used now.

\ The first definition allows for conditional 
\ compilation of one line words on any ANS Forth..

\ -- Stack comments ---------------------------------------

?: ( 41 word drop ; immediate

\ SLOTH v1.0

\ TODO Explain SLOTH

\ -- Compilation ------------------------------------------

?: , ( x -- ) here ! 1 cells allot ;
?: C, ( char -- ) here c! 1 chars allot ;

\ POSTPONE its a long word that also does not show that its 
\ a parsing word. This definition corrects both problems:

?: P: ( "<spaces>name" -- ) postpone postpone ; immediate

\ PLATFORM DEPENDENT
?: LITERAL ( C: x -- ) ( -- x ) p: LIT , ; immediate

\ -- Control structures -----------------------------------

\ This words have a good balance between simplicity and
\ usefulness. Some more complicated words (like DO/LOOP)
\ are not implemented now.

\ PLATFORM DEPENDENT (depends on implementation of BRANCH)
?: AHEAD ( C: -- orig ) ( -- ) p: branch here 0 , ; immediate
\ PLATFORM DEPENDENT (depends on implementation of ?BRANCH)
?: IF ( C: -- orig ) ( x -- ) p: ?branch here 0 , ; immediate
?: THEN ( C: -- orig ) ( -- ) here over - swap ! ; immediate
?: ELSE ( C: orig1 -- orig2 ) ( -- ) p: ahead swap p: then ; immediate

?: BEGIN ( C: -- dest ) ( -- ) here ; immediate
\ PLATFORM DEPENDENT (depends on implementation of ?BRANCH)
?: UNTIL ( C: dest -- ) ( x -- ) p: ?branch here - , ; immediate
\ PLATFORM DEPENDENT (depends on implementation of BRANCH)
?: AGAIN ( C: dest -- ) ( -- ) p: branch here - , ; immediate
?: WHILE ( C: dest -- orig dest ) ( x -- ) p: if swap ; immediate
?: REPEAT	( C: orig dest -- ) ( -- ) p: again p: then ; immediate

\ ---------------------------------------------------------

\ Now that we have conditional compilation and basic 
\ control structures, we can implement a lot of fundamental 
\ words.

\ -- Stack shuffling --------------------------------------

\ The only required primitives for stack shuffling are:
\ DROP PICK OVER SWAP >R R>

?: DUP ( x -- x x ) 0 pick ;
?: ?DUP	( x -- 0 | x x ) dup if dup then ;

?: R@ ( -- x ) ( R: x -- x ) p: r> p: dup p: >r ; immediate

?: ROT ( x1 x2 x3 -- x2 x3 x1 ) >r swap r> swap ;	
?: -ROT ( x1 x2 x3 -- x3 x1 x2 ) rot rot ;
?: NIP ( x1 x2 -- x2 ) swap drop ;
?: TUCK ( x1 x2 -- x2 x1 x2 ) >r r@ swap r> ;

( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
?: ROLL dup if swap >r 1 - recurse r> swap exit then drop ;

?: 2DROP ( x1 x2 -- ) drop drop ;
?: 2DUP ( x1 x2 -- x1 x2 x1 x2 ) over over ;
?: 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 ) 3 pick 3 pick ;

?: 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 ) >r -rot r> -rot ;

?: 2>R ( x1 x2 -- ) ( R: -- x1 x2 ) p: swap p: >r p: >r ; immediate
?: 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 ) p: r> p: r> p: swap p: 2dup p: swap p: >r p: >r ; immediate
?: 2R> ( -- x1 x2 ) ( R: x1 x2 -- ) p: r> p: r> p: swap ; immediate

?: 2RDROP	( x1 x2 -- ) p: r> p: r> p: drop p: drop ; immediate

\ -- Arithmetic -------------------------------------------

?: + ( n1 | u1 n2 | u2 -- n3 | u3 ) 0 swap - - ;
?: * ( n1 | u1 n2 | u2 -- n3 | u3 ) 1 */mod swap drop ;
?: / ( n1 n2 -- n3 ) 1 swap */mod swap drop ;
?: */ ( n1 n2 n3 -- n4 ) */mod swap drop ;
?: MOD ( n1 n2 -- n3 ) 1 swap */mod drop ;
?: /MOD	( n1 n2 -- n3 n4 ) 1 swap */mod ;

?: 1+ ( n1 | u1 -- n2 | u2 ) 1 + ;
?: 1- ( n1 | u1 -- n2 | u2 ) 1 - ;

?: 2* ( x1 -- x2 ) 2 * ;

?: ABS ( n -- u ) dup 0 < if invert 1+ then ;

\ -- Bit\Logic --------------------------------------------

?: NEGATE ( n1 -- n2 ) invert 1+ ;

?: OR	( x1 x2 -- x3 ) invert swap invert and invert ;
?: XOR ( x1 x2 -- x3 ) over over invert and >r swap invert and r> or ;

\ -- Comparisons ------------------------------------------

?: < ( n1 n2 -- flag ) 2dup xor 0< if drop 0< else - 0< then ;
?: > ( n1 n2 -- flag ) swap < ;
?: <=	( n1 n2 -- flag ) > invert ;
?: >=	( n1 n2 -- flag ) < invert ;
?: 0=	( x -- flag ) if 0 else 0 invert then ;
?: 0> ( x -- flag ) 0 > ;
?: 0<> ( x -- flag ) 0= 0= ;
?: 0< ( x -- flag ) 0 < ;
?: NOT ( x1 -- x2 ) 0= ;
?: = ( x1 x2 -- flag ) - 0= ;
?: <> ( x1 x2 -- flag ) = invert ;
?: U<	( u1 u2 -- flag ) 2dup xor 0< if swap drop 0< else - 0< then ;
?: U>	( u1 u2 -- flag ) swap u< ;
?: WITHIN ( n1 | u1 n2 | u2 n3 | u3 -- flag ) over - >r - r> u< ; 

?: MIN ( n1 n2 -- n3 ) 2dup > if swap then drop ;
?: MAX ( n1 n2 -- n3 ) 2dup < if swap then drop ;

\ -- Memory -----------------------------------------------

?: CELL ( -- u ) 1 cells ;

?: CELL+ ( a-addr1 -- a-addr2 ) 1 cells + ;
?: CHAR+ ( c-addr1 -- c-addr2 ) 1 chars + ;
?: CELL- ( a-addr1 -- a-addr2 ) 1 cells - ;
?: CHAR- ( c-addr1 -- c-addr2 ) 1 chars - ;

?: ALIGNED ( addr -- a-addr ) cell+ 1- 1 cells 1- invert and ;
?: ALIGN ( -- ) here aligned here - allot ;

\ PLATFORM DEPENDENT - NON ANS
?: HERE, ( x -- ) here 2 cells + p: literal ;

?: 0! ( a-addr -- ) 0 swap ! ;
?: +! ( n | u a-addr -- ) swap over @ + swap ! ;
?: 1+! ( a-addr -- ) dup @ 1 + swap ! ;
?: 1-! ( a-addr -- ) dup @ 1 - swap ! ;

?: 2! ( x1 x2 a-addr -- ) swap over ! cell+ ! ;
?: 2@	( a-addr -- x1 x2 ) dup cell+ @ swap @ ;

\ ANS Forth talks about address units (the minimum
\ addresable unit in memory space), but offers no
\ words to work with them (except of MOVE).

\ B@ and B! allow working with address units which
\ normally are the same as characters. In cases where
\ that is not true (like the Java implementation of SLOTH)
\ then B@ and B! must be defined in the bootstrap code.

?: B@		C@ ;
?: B!		C! ;

\ MOVE deals with address units.

\ TODO Lets deal with weird cases when I can test everything

?: MOVE ( addr1 addr2 u -- ) begin dup 0> while >r over b@ over b! 1+ swap 1+ swap r> 1- repeat drop drop drop ;

?: FILL ( c-addr u char -- ) -rot begin dup 0> while >r 2dup c! char+ r> 1- repeat drop drop drop ;

?: ERASE ( addr u -- ) begin dup 0> while >r 0 over b! 1+ r> 1- repeat drop drop ;

\ BOUNDS is not an ANS word, but its useful.
?: BOUNDS ( c-addr u -- c-addr1 c-addr2 ) over + swap ;
