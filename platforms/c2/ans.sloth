: ?: 32 WORD FIND SWAP DROP 0 = 1 + SOURCE SWAP DROP OVER * SWAP 1 SWAP - + >IN ! ;

?: \ SOURCE >IN ! DROP ; IMMEDIATE

\ End of line comments can be used now.

\ The first definition allows for conditional 
\ compilation of one line words on any ANS Forth..

\ SLOTH v1.0

\ TODO Explain SLOTH

\ As per ANS Forth standard, all definitions names are
\ created and used in upper case (although I prefer the
\ upper case for definition/lower case for use, I think
\ its easier to read).

\ -- Stack comments ---------------------------------------

?: ( 41 WORD DROP ; IMMEDIATE

\ -- Compilation ------------------------------------------

?: , ( x -- ) HERE ! 1 CELLS ALLOT ;
?: C, ( char -- ) HERE C! 1 CHARS ALLOT ;

\ POSTPONE its a long word that also does not show that its 
\ a parsing word. This definition corrects both problems:

?: P: ( "<spaces>name" -- ) POSTPONE POSTPONE ; IMMEDIATE

\ PLATFORM DEPENDENT
?: LITERAL ( C: x -- ) ( -- x ) P: LIT , ; IMMEDIATE

?: ' ( "<spaces>name" -- xt ) 32 WORD FIND DROP ; 
?: ['] ( "<spaces>name" -- ) ( R: -- xt ) ' P: LITERAL ; IMMEDIATE

\ -- Variables and constants ------------------------------

?: VARIABLE ( "<spaces>name" -- ) CREATE 0 , ;
?: CONSTANT ( x "<spaces>name" -- ) CREATE , DOES> @ ;

\ -- Control structures -----------------------------------

\ This words have a good balance between simplicity and
\ usefulness. Some more complicated words (like DO/LOOP)
\ are not implemented now.

\ PLATFORM DEPENDENT (depends on implementation of BRANCH)
?: AHEAD ( C: -- orig ) ( -- ) P: BRANCH HERE 0 , ; IMMEDIATE
\ PLATFORM DEPENDENT (depends on implementation of ?BRANCH)
?: IF ( C: -- orig ) ( x -- ) P: ?BRANCH HERE 0 , ; IMMEDIATE
?: THEN ( C: -- orig ) ( -- ) HERE OVER - SWAP ! ; IMMEDIATE
?: ELSE ( C: orig1 -- orig2 ) ( -- ) P: AHEAD SWAP P: THEN ; IMMEDIATE

?: BEGIN ( C: -- dest ) ( -- ) HERE ; IMMEDIATE
\ PLATFORM DEPENDENT (depends on implementation of ?BRANCH)
?: UNTIL ( C: dest -- ) ( x -- ) P: ?BRANCH HERE - , ; IMMEDIATE
\ PLATFORM DEPENDENT (depends on implementation of BRANCH)
?: AGAIN ( C: dest -- ) ( -- ) P: BRANCH HERE - , ; IMMEDIATE
?: WHILE ( C: dest -- orig dest ) ( x -- ) P: IF SWAP ; IMMEDIATE
?: REPEAT	( C: orig dest -- ) ( -- ) P: AGAIN P: THEN ; IMMEDIATE

\ ---------------------------------------------------------

\ Now that we have conditional compilation and basic 
\ control structures, we can implement a lot of fundamental 
\ words.

\ -- Stack shuffling --------------------------------------

\ The only required primitives for stack shuffling are:
\ DROP PICK OVER SWAP >R R>

?: DUP ( x -- x x ) 0 PICK ;
?: ?DUP	( x -- 0 | x x ) DUP IF DUP THEN ;

?: R@ ( -- x ) ( R: x -- x ) P: R> P: DUP P: >R ; IMMEDIATE

?: ROT ( x1 x2 x3 -- x2 x3 x1 ) >R SWAP R> SWAP ;	
\ Not ANS
?: -ROT ( x1 x2 x3 -- x3 x1 x2 ) ROT ROT ;
?: NIP ( x1 x2 -- x2 ) SWAP DROP ;
?: TUCK ( x1 x2 -- x2 x1 x2 ) >R R@ SWAP R> ;

( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
?: ROLL DUP IF SWAP >R 1 - RECURSE R> SWAP EXIT THEN DROP ;

?: 2DROP ( x1 x2 -- ) DROP DROP ;
?: 2DUP ( x1 x2 -- x1 x2 x1 x2 ) OVER OVER ;
?: 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 ) 3 PICK 3 PICK ;

?: 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 ) >R -ROT R> -ROT ;

?: 2>R ( x1 x2 -- ) ( R: -- x1 x2 ) P: SWAP P: >R P: >R ; IMMEDIATE
?: 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 ) P: R> P: R> P: SWAP P: 2DUP P: SWAP P: >R P: >R ; IMMEDIATE
?: 2R> ( -- x1 x2 ) ( R: x1 x2 -- ) P: R> P: R> P: SWAP ; IMMEDIATE

?: 2RDROP	( x1 x2 -- ) P: R> P: R> P: DROP P: DROP ; IMMEDIATE

\ -- Arithmetic -------------------------------------------

?: + ( n1 | u1 n2 | u2 -- n3 | u3 ) 0 SWAP - - ;
?: * ( n1 | u1 n2 | u2 -- n3 | u3 ) 1 */MOD SWAP DROP ;
?: / ( n1 n2 -- n3 ) 1 SWAP */MOD SWAP DROP ;
?: */ ( n1 n2 n3 -- n4 ) */MOD SWAP DROP ;
?: MOD ( n1 n2 -- n3 ) 1 SWAP */MOD DROP ;
?: /MOD	( n1 n2 -- n3 n4 ) 1 SWAP */MOD ;

?: 1+ ( n1 | u1 -- n2 | u2 ) 1 + ;
?: 1- ( n1 | u1 -- n2 | u2 ) 1 - ;

?: 2* ( x1 -- x2 ) 2 * ;

?: ABS ( n -- u ) DUP 0 < IF INVERT 1+ THEN ;

\ -- Bit\Logic --------------------------------------------

?: NEGATE ( n1 -- n2 ) INVERT 1+ ;

?: OR	( x1 x2 -- x3 ) INVERT SWAP INVERT AND INVERT ;
?: XOR ( x1 x2 -- x3 ) OVER OVER INVERT AND >R SWAP INVERT AND R> OR ;

\ -- Comparisons ------------------------------------------

?: < ( n1 n2 -- flag ) 2DUP XOR 0< IF DROP 0< ELSE - 0< THEN ;
?: > ( n1 n2 -- flag ) SWAP < ;
?: <=	( n1 n2 -- flag ) > INVERT ;
?: >=	( n1 n2 -- flag ) < INVERT ;
?: 0=	( x -- flag ) IF 0 ELSE 0 INVERT THEN ;
?: 0> ( x -- flag ) 0 > ;
?: 0<> ( x -- flag ) 0= 0= ;
?: 0< ( x -- flag ) 0 < ;
?: NOT ( x1 -- x2 ) 0= ;
?: = ( x1 x2 -- flag ) - 0= ;
?: <> ( x1 x2 -- flag ) = INVERT ;
?: U<	( u1 u2 -- flag ) 2DUP XOR 0< IF SWAP DROP 0< ELSE - 0< THEN ;
?: U>	( u1 u2 -- flag ) SWAP U< ;
?: WITHIN ( n1 | u1 n2 | u2 n3 | u3 -- flag ) OVER - >R - R> U< ; 

?: MIN ( n1 n2 -- n3 ) 2DUP > IF SWAP THEN DROP ;
?: MAX ( n1 n2 -- n3 ) 2DUP < IF SWAP THEN DROP ;

\ -- Memory -----------------------------------------------

?: CELL ( -- u ) 1 CELLS ;

?: CELL+ ( a-addr1 -- a-addr2 ) 1 CELLS + ;
?: CHAR+ ( c-addr1 -- c-addr2 ) 1 CHARS + ;
?: CELL- ( a-addr1 -- a-addr2 ) 1 CELLS - ;
?: CHAR- ( c-addr1 -- c-addr2 ) 1 CHARS - ;

?: ALIGNED ( addr -- a-addr ) CELL+ 1- 1 CELLS 1- INVERT AND ;
?: ALIGN ( -- ) HERE ALIGNED HERE - ALLOT ;

\ PLATFORM DEPENDENT - NON ANS
?: HERE, ( x -- ) HERE 2 CELLS + P: LITERAL ;

?: 0! ( a-addr -- ) 0 SWAP ! ;
?: +! ( n | u a-addr -- ) SWAP OVER @ + SWAP ! ;
?: 1+! ( a-addr -- ) DUP @ 1 + SWAP ! ;
?: 1-! ( a-addr -- ) DUP @ 1 - SWAP ! ;

?: 2! ( x1 x2 a-addr -- ) SWAP OVER ! CELL+ ! ;
?: 2@	( a-addr -- x1 x2 ) DUP CELL+ @ SWAP @ ;

\ ANS Forth talks about address units (the minimum
\ addresable unit in memory space), but offers no
\ words to work with them (except of MOVE).

\ B@ and B! allow working with address units which
\ normally are the same as characters. In cases where
\ that is not true (like the Java implementation of SLOTH)
\ then B@ and B! must be defined in the bootstrap code.

\ TODO Maybe there's no B@ B! because there is no need for it.

?: B@		C@ ;
?: B!		C! ;

\ MOVE deals with address units.

\ TODO Lets deal with weird cases when I can test everything

?: MOVE ( addr1 addr2 u -- ) BEGIN DUP 0> WHILE >R OVER B@ OVER B! 1+ SWAP 1+ SWAP R> 1- REPEAT DROP DROP DROP ;

?: FILL ( c-addr u char -- ) -ROT BEGIN DUP 0> WHILE >R 2DUP C! CHAR+ R> 1- REPEAT DROP DROP DROP ;

?: ERASE ( addr u -- ) BEGIN DUP 0> WHILE >R 0 OVER B! 1+ R> 1- REPEAT DROP DROP ;

\ BOUNDS is not an ANS word, but its useful.
?: BOUNDS ( c-addr u -- c-addr1 c-addr2 ) OVER + SWAP ;
